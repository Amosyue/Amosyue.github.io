<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Js里new Function语法</title>
    <link href="/2022/09/03/newFunction/"/>
    <url>/2022/09/03/newFunction/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一般我们不会使用用 new Function 构造函数的，因为没必要，直接使用 function 或者 箭头函数写法更简单。但并不是说new Function 构造函数无用。在一些特别的场景，比如函数体的数据格式是字符串的时候，new Function 构造函数的作用就显示出来了。之前也是仅仅知道此方法，但是没有具体的研究搞懂，但是最近一两年一直在倒腾低代码的项目，原理上来说，低代码都是一堆字符串，为了解析字符串就使用了new Function 构造函数（eval方法也是可以的），在此在记录一下，加深理解。详情参见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions</a></p></blockquote><h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><blockquote><p>备注： 不推荐使用 Function 构造函数创建函数，因为它需要的函数体作为字符串可能会阻止一些 JS 引擎优化，也会引起其他问题。把 Function 的构造函数当作函数一样调用 (不使用 new 操作符) 的效果与作为 Function 的构造函数调用一样。</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">let func = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Function</span> <span class="hljs-title"></span>([arg1, arg2, ...argN], functionBody);<br><br>//等价于 let func = <span class="hljs-keyword">Function</span> <span class="hljs-title"></span>([arg1, arg2, ...argN], functionBody);<br></code></pre></td></tr></table></figure><p><font color="red">Function构造函数所有的参数都是字符串类型。除了最后一个参数, 其余的参数都作为生成函数的参数即形参。这里可以没有参数。最后一个参数, 表示的是要创建函数的函数体。</font></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">//传入参数</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">sum</span> = <span class="hljs-literal">new</span> Function(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>);<br>console.<span class="hljs-keyword">log</span>( <span class="hljs-keyword">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">//不传入参数</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">sum</span> = <span class="hljs-literal">new</span> Function(<span class="hljs-string">&#x27;console.log(1)&#x27;</span>);<br>console.<span class="hljs-keyword">log</span>( <span class="hljs-keyword">sum</span>() ); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>由于历史原因，new Function参数也可以以逗号分隔的列表形式给出。下边这三个声明的含义相同：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Function(&#x27;<span class="hljs-params">a</span>&#x27;, &#x27;<span class="hljs-params">b</span>&#x27;, &#x27;<span class="hljs-params">return</span> <span class="hljs-params">a</span> + <span class="hljs-params">b</span>&#x27;)</span>; <br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Function(&#x27;<span class="hljs-params">a</span>,<span class="hljs-params">b</span>&#x27;, &#x27;<span class="hljs-params">return</span> <span class="hljs-params">a</span> + <span class="hljs-params">b</span>&#x27;)</span>; <br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Function(&#x27;<span class="hljs-params">a</span> , <span class="hljs-params">b</span>&#x27;, &#x27;<span class="hljs-params">return</span> <span class="hljs-params">a</span> + <span class="hljs-params">b</span>&#x27;)</span>;<br></code></pre></td></tr></table></figure><h2 id="2、作用域"><a href="#2、作用域" class="headerlink" title="2、作用域"></a>2、作用域</h2><p>Function()构造函数和函数有一点就是：使用构造函数Function()创建的函数不使用当前的词法作用域，相反的，它们总是被顶级函数来编译，因此在运行时它们只能访问全局变量和自己的局部变量.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span><br>  <span class="hljs-keyword">let</span> result1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;console.log(a)&#x27;</span>)<br>  <span class="hljs-keyword">let</span> result2 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>  <span class="hljs-title function_">result1</span>() <span class="hljs-comment">//打印出1，访问的是全局变量a</span><br>  <span class="hljs-title function_">result2</span>() <span class="hljs-comment">//打印出2</span><br>&#125;<br><span class="hljs-title function_">fn</span>()<br><span class="hljs-comment">// new Function这样的函数不能访问外部变量，只能访问全局变量</span><br><span class="hljs-comment">// 虽然这段代码可以在浏览器中正常运行，但在 Node.js 中，result1() 执行会报错，因为找不到变量 a。</span><br><span class="hljs-comment">// 这是因为，在 Node 中，顶级作用域不是全局作用域，而 a 其实是在模块的作用域之中。</span><br></code></pre></td></tr></table></figure><p>想象一下，我们必须从一个字符串创建一个函数。该函数的代码在编写脚本时是未知的，但是会在执行过程中知道。我们可能会从服务器或其他地方接收到它。此时我们的新函数需要与主脚本交互，如果它此时它可以访问外部变量，那么就可以操作外部变量，改变外部变量，这样就会引发不可预估的风险。</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>假如有一个非合法 JSON 对象字符串,如下：</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&#123; name: &#x27;小坦克&#x27;, code: 100 &#125;&quot;</span> <br>JSON.parse(<span class="hljs-built_in">str</span>) <span class="hljs-comment">// 会报错，因为str字段是不符合规范的对象字符串（key,value都必须是&quot;&quot;，双引号包裹）</span><br></code></pre></td></tr></table></figure><p>可以使用new Function</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&#123; name: &#x27;小坦克&#x27;, code: 100 &#125;&quot;</span> <br><span class="hljs-keyword">let</span> result =  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Function(&#x27;<span class="hljs-params">return</span> &#x27; + <span class="hljs-params">str</span>)</span><span class="hljs-literal">()</span>) <span class="hljs-comment">// result = &#123; name: &#x27;小坦克&#x27;, code: 100 &#125;</span><br></code></pre></td></tr></table></figure><h2 id="4、new-Function和eval的区别"><a href="#4、new-Function和eval的区别" class="headerlink" title="4、new Function和eval的区别"></a>4、new Function和eval的区别</h2><p>eval中的代码执行时的作用域为当前作用域。它可以访问到函数中的局部变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span><br>  <span class="hljs-keyword">let</span> result1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;console.log(a)&#x27;</span>)<br>  <span class="hljs-keyword">let</span> result2 = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;console.log(a)&#x27;</span>) <span class="hljs-comment">//打印出2</span><br>  <span class="hljs-title function_">result1</span>() <span class="hljs-comment">//打印出1，访问的是全局变量a</span><br>&#125;<br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><p><font color="red"><b>永远不要使用 eval !!!</b></font></p><p>eval() 是一个危险的函数， 它使用与调用者相同的权限执行代码。如果你用 eval() 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页&#x2F;扩展程序的权限下，在用户计算机上运行恶意代码。更重要的是，第三方代码可以看到某一个 eval() 被调用时的作用域，这也有可能导致一些不同方式的攻击。相似的 Function 就不容易被攻击</p><p>eval() 通常比其他替代方法更慢，因为它必须调用 JS 解释器，而许多其他结构则可被现代 JS 引擎进行优化。</p><p>此外，现代 JavaScript 解释器将 JavaScript 转换为机器代码。这意味着任何变量命名的概念都会被删除。因此，任意一个 eval 的使用都会强制浏览器进行冗长的变量名称查找，以确定变量在机器代码中的位置并设置其值。另外，新内容将会通过 eval() 引进给变量，比如更改该变量的类型，因此会强制浏览器重新执行所有已经生成的机器代码以进行补偿。但是（谢天谢地）存在一个非常好的 eval 替代方法：只需使用 window.Function。这有个例子方便你了解如何将eval()的使用转变为Function()。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown</title>
    <link href="/2022/07/22/markdown/"/>
    <url>/2022/07/22/markdown/</url>
    
    <content type="html"><![CDATA[<p>语法地址：<a href="https://docs.github.com/cn/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">https://docs.github.com/cn/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax</a></p><p><a href="https://keatonlao.gitee.io/a-study-note-for-markdown/syntax/">https://keatonlao.gitee.io/a-study-note-for-markdown/syntax/</a></p><h1 id="最大标题"><a href="#最大标题" class="headerlink" title="最大标题"></a>最大标题</h1><h2 id="第二大标题"><a href="#第二大标题" class="headerlink" title="第二大标题"></a>第二大标题</h2><h6 id="最小标题"><a href="#最小标题" class="headerlink" title="最小标题"></a>最小标题</h6><p>这个是引用的格式</p><blockquote><p>Text that is a quote</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">这个是应用的格式<br>&gt; Text <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> a <span class="hljs-literal">quote</span><br><br></code></pre></td></tr></table></figure><p><font color="red">我是红色</font><br><font color="#008000">我是绿色</font></p><div bgcolor="yellow">背景是黄色</div><table><tr><td bgcolor="yellow">背景色yellow</td></tr></table><center>文字居中</center><p>####小坦克</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2022/02/11/git/"/>
    <url>/2022/02/11/git/</url>
    
    <content type="html"><![CDATA[<blockquote><p>现在一直在坚持使用git命令来完成代码的管理，但是有些命令总是记不住，或者当时记住了，过些日子又忘记了，在这里在记录一下把。</p></blockquote><h2 id="1、git单独拉取指定分支"><a href="#1、git单独拉取指定分支" class="headerlink" title="1、git单独拉取指定分支"></a>1、git单独拉取指定分支</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//方法1</span><br>git clone -b <span class="hljs-built_in">dev</span> xxx(git地址) <span class="hljs-comment">//拉取dev分支</span><br><br><span class="hljs-comment">//方法2</span><br>git fetch origin <span class="hljs-built_in">dev</span> 然后 git checkout <span class="hljs-built_in">dev</span><br><br><span class="hljs-comment">//方法3 </span><br>git fetch origin <span class="hljs-built_in">dev</span> 然后 git checkout --track origin/<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><h2 id="1、git关联指定分支"><a href="#1、git关联指定分支" class="headerlink" title="1、git关联指定分支"></a>1、git关联指定分支</h2><p>（情况1）如果远程新建了一个分支，本地没有该分支<br>可以利用 git checkout –track origin&#x2F;branch_name ，这时本地会新建一个分支名叫 branch_name ，会自动跟踪远程的同名分支 branch_name。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git checkout --<span class="hljs-built_in">track</span> <span class="hljs-built_in">origin</span>/branch_name<br></code></pre></td></tr></table></figure><p>（情况2）如果本地新建了一个分支 branch_name，但是在远程没有的情况<br>这时候 push 和 pull 指令就无法确定该跟踪谁，一般来说我们都会使其跟踪远程同名分支，所以可以利用 git push –set-upstream origin branch_name ，这样就可以自动在远程创建一个 branch_name 分支，然后本地分支会 track 该分支。后面再对该分支使用 push 和 pull 就自动同步。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> --set-upstream <span class="hljs-built_in">origin</span> branch_name<br>//简写 git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> branch_name<br></code></pre></td></tr></table></figure><p>（情况3）本地创建一个名为debug的分支，然后执行如下代码，就会把本地debug分支关联远程debug分支。</p><p>git branch –set-upstream debug origin&#x2F;debug&#x2F;&#x2F;貌似–set-upstream已经失效，提示track或者–set-upstream-to代替<br>git branch –set-upstream-to origin&#x2F;newName</p><h2 id="合并某个分支上的单个commit"><a href="#合并某个分支上的单个commit" class="headerlink" title="合并某个分支上的单个commit"></a>合并某个分支上的单个commit</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git cherry-pick &lt;commit-<span class="hljs-built_in">id</span>&gt; 把某个commit <span class="hljs-built_in">id</span>提交合并到当前分支<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入setTimeout,setInterval</title>
    <link href="/2020/03/02/settimeout/"/>
    <url>/2020/03/02/settimeout/</url>
    
    <content type="html"><![CDATA[<h2 id="1、setTimeout-常规用法"><a href="#1、setTimeout-常规用法" class="headerlink" title="1、setTimeout,常规用法"></a>1、setTimeout,常规用法</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;执行了方法&quot;</span>)<span class="hljs-comment">//1秒后打印出：执行了方法</span><br>&#125;,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>setTimeout第一个参数我们使用的是一个函数，但其实也可以是字符串，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">setTimeout</span><span class="hljs-params">(<span class="hljs-string">&quot;console.log(&#x27;执行了方法&#x27;)&quot;</span>,<span class="hljs-number">1000</span>)</span></span><span class="hljs-comment">////1秒后打印出：执行了方法</span><br></code></pre></td></tr></table></figure><p>但是我们一般不会这样用，原因和使用 eval()一样，有安全风险。</p><h2 id="2、setTimeout返回值"><a href="#2、setTimeout返回值" class="headerlink" title="2、setTimeout返回值"></a>2、setTimeout返回值</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let timeoutID = setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;执行了方法&quot;</span>)<br>&#125;,<span class="hljs-number">1000</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> timeoutID) <span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure><p>返回值timeoutID是一个正整数，表示定时器的编号。这个值可以传递给clearTimeout()来取消该定时器。需要注意的是 setTimeout() 和 setInterval() 共用一个编号池，技术上，clearTimeout() 和 clearInterval() 可以互换。但是，为了避免混淆，不要混用取消定时函数。</p><h2 id="3、0延迟的setTimeout"><a href="#3、0延迟的setTimeout" class="headerlink" title="3、0延迟的setTimeout"></a>3、0延迟的setTimeout</h2><p>比如：setTimeout(func, 0)，或者setTimeout(func).<br>func函数会尽快安排执行。但是调度程序只有在当前执行的脚本完成后才会调用它。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> alert(<span class="hljs-string">&quot;World&quot;</span>)); <span class="hljs-regexp">//</span>先弹出Hello,然后在弹出World<br><br>alert(<span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="4、setInterval"><a href="#4、setInterval" class="headerlink" title="4、setInterval"></a>4、setInterval</h2><p>setInterval会无视代码错误。就算代码中遇到了错误，它还是会一直循环下去，这样可能会导致你的浏览器卡死。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>;<br>setInterval(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">count</span>++;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;setInterval报错&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p><img src="/2020/03/02/settimeout/1.3.png" alt="setTimeout示意图"><br>「定时器」通常有两种，一种是固定地每间隔一定时间触发一下，就像钟表那样,这个时候使用setInterval最好；另一种是在前一次触发之后，间隔一段时间再触发下一次，通常这种在触发时都会需要执行一个比较耗时的异步任务，此时使用setTimeout（具体是setTimeout + 递归来实现）。如下：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> <span class="hljs-params">()</span> </span>&#123;<br>  setTimeout(() =&gt; &#123;<br>    <span class="hljs-comment">// 程序主逻辑代码</span><br>    <span class="hljs-comment">// 循环递归调用</span><br>    test()<span class="hljs-comment">//因为此函数中途会报错，只会执行一次就结束了。</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span><span class="hljs-params">()</span></span>;<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000000</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">9999999</span>)&#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;出错了&#x27;</span><br>    &#125;<br>  &#125;<br>  console.log(<span class="hljs-string">&quot;成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、setTimeout对比setInterval"><a href="#5、setTimeout对比setInterval" class="headerlink" title="5、setTimeout对比setInterval"></a>5、setTimeout对比setInterval</h2><p>1、setTimeout() 方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。<br>2、setInterval() 方法重复调用一个函数或执行一个代码片段，在每次调用之间具有固定的时间间隔。<br><img src="/2020/03/02/settimeout/1.2.png" alt="setTimeout示意图"><br><img src="/2020/03/02/settimeout/1.1.png" alt="setInterval示意图"><br>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p><h2 id="6、setTimeout模拟setInterval"><a href="#6、setTimeout模拟setInterval" class="headerlink" title="6、setTimeout模拟setInterval"></a>6、setTimeout模拟setInterval</h2><p>每个 setTimeout 产生的任务会直接 push 到任务队列中；而 setInterval 在每次把任务 push 到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中，如果有则不添加，没有则添加,这是在浏览器的v8环境，node环境是每次都push)。</p><h5 id="为什么使用setTimeout模拟setInterval"><a href="#为什么使用setTimeout模拟setInterval" class="headerlink" title="为什么使用setTimeout模拟setInterval?"></a>为什么使用setTimeout模拟setInterval?</h5><p>setInterval 缺点：</p><blockquote><p>某些间隔会被跳过（丢帧现象）<br>定时器之间的间隔会比预期小</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const mySetInterval =<span class="hljs-function"> (<span class="hljs-params">fn</span>, <span class="hljs-params">delay</span>, <span class="hljs-params">t</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">do</span><span class="hljs-constructor">Fn()</span> &#123;<br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">test</span>, <span class="hljs-params">delay</span>)</span>;<br>    <span class="hljs-keyword">if</span>( t-- &gt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        fn<span class="hljs-literal">()</span><br>      &#125; catch (error) &#123;<br>        t = <span class="hljs-number">0</span> <span class="hljs-comment">//如果fn函数出错了，终止递归</span><br>        throw &#x27;出错了&#x27;<br>      &#125;<br>    &#125;<br>  &#125;<br>  set<span class="hljs-constructor">Timeout(<span class="hljs-params">doFn</span>, <span class="hljs-params">delay</span>)</span>;<br>&#125;;<br><br>my<span class="hljs-constructor">SetInterval(<span class="hljs-params">function</span> ()</span> &#123;<br>  console.log(&#x27;hello word&#x27;);<br>&#125;, <span class="hljs-number">1000</span>,<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h2 id="7、弊端"><a href="#7、弊端" class="headerlink" title="7、弊端"></a>7、弊端</h2><p>1、setTimeout 会引发内存泄漏（内层函数私有作用域不会销毁）， 所以在实现动画效果时，尽量用CSS3做动画。setTimeout 使用完后要使用 clearTimeout 清除掉。<br>2、每一个 setTimeout 都是在增加一个新的 JavaScript 任务，会影响浏览器主线程（main thread)的，会造成一定程度达到卡机。<br>3、如果是在写测试的话，用setTimeout 会导致你的测试不稳定（flaky)。</p><h2 id="8、其它"><a href="#8、其它" class="headerlink" title="8、其它"></a>8、其它</h2><p>setTimeout()、setInterval() 允许传入一个JS代码字符串并执行，然而在JS代码中执行另一段JS代码时，代码首先会以正常的方式求值，然后在执行过程中对包含于字符串中的代码发起另一个求值运算，从而造成双重求值。它比直接包含的代码执行速度慢很多，原因在于， 每次调用setTimeout()、setInterval() 都会创建一个新的解释器&#x2F;编译器实例。这必然使得代码执行速度变慢，效率降低，从而造成性能的浪费。所以建议传入函数而不是字符串来作为第一个参数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>深入setTimeout</tag>
      
      <tag>setInterval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>express+mockjs+nodemon 搭建一个mock服务</title>
    <link href="/2019/10/23/mock/"/>
    <url>/2019/10/23/mock/</url>
    
    <content type="html"><![CDATA[<blockquote><p>express+mockjs+nodemon 搭建一个mock服务，方便前端开发 (demo已经上传到github，地址：<a href="https://github.com/Amosyue/mockServe">https://github.com/Amosyue/mockServe</a></p></blockquote><h2 id="使用mockjs的方式"><a href="#使用mockjs的方式" class="headerlink" title="使用mockjs的方式"></a>使用mockjs的方式</h2><p>1、在项目入口文件中直接引入配置好的mock文件</p><p>这种方法需要在项目内引入mock并创建相关配置文件，根据环境来配置，代码耦合度太高</p><p>2、配合express启一个服务</p><p>这样就相当于模拟了真实的接口，netWork可以看到请求，并且可以不在该项目中做任何配置直接向服务发起请求即可。<br>这里我们只说下第二种情况，这样项目和mock数据分离，需要mock数据的时候只需要启动本地mock服务即可，代码耦合度低。</p><p>实例操作配置</p><p>1、安装express,mockjs</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> express mockjs <span class="hljs-attr">--save-dev</span><br></code></pre></td></tr></table></figure><p>2、在项目的根目录创建index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)(); <span class="hljs-comment">//实例化express</span><br><span class="hljs-comment">// 代理部分请求</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/proxy/lanmu1/test2&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;post /lanmu1/test2&#x27;</span>)<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;token string&#x27;</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;mock-server：模拟数据&#x27;</span><br>  &#125;)<br>&#125;);<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/mock/api&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-comment">// mockjs中属性名‘|’符号后面的属性为随机属性，数组对象后面的随机属性为随机数组数量，正则表达式表示随机规则，+1代表自增</span><br>  res.<span class="hljs-title function_">json</span>(&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&#x27;ss999999&#x27;</span>&#125;);<br>&#125;);<br><span class="hljs-comment">// 监听3001端口</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;3001&#x27;</span>);<br></code></pre></td></tr></table></figure><p>3、设置启动命令</p><p>如果不设置启动命令，那么此步骤可省略。启动命令默认是 node index.js.<br>如果配置启动命令如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这样只需要npm run mock就可以了<br>到这里其实简单的mock服务已经配置好了，运行npm run mock，项目就可以启动了，你可以在其他项目中调用你写在mock服务里的接口了。</p><p>4、配置nodemon</p><p>到第3步，其实已经配置好了，但是有个小问题，如果你添加或者删除了默写数据接口，你必须重启服务，没有热更新，这步就是为了解决这个问题。</p><p>1、安装nodemon</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> nodemon  <span class="hljs-attr">--save-dev</span><br></code></pre></td></tr></table></figure><p>2、在根目录创建serve.js</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> nodemon = require(<span class="hljs-string">&#x27;nodemon&#x27;</span>); <span class="hljs-comment">//引入nodemon模块</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * script 重启的脚本</span><br><span class="hljs-comment"> * ext 检测的文件类型</span><br><span class="hljs-comment"> * watch 监听哪些文件，文件夹，如果配置此字段，那么nodemon就会匹配当前字段下的文件</span><br><span class="hljs-comment"> * ignore 忽略哪些文件</span><br><span class="hljs-comment"> */</span><br>nodemon(&#123;<br>  <span class="hljs-attr">script</span>: <span class="hljs-string">&#x27;./index.js&#x27;</span>,<br>  <span class="hljs-attr">ignore</span>:[],<br>  <span class="hljs-attr">watch</span>: [<br>    <span class="hljs-string">&#x27;api/&#x27;</span>,<br>    <span class="hljs-string">&#x27;index.js&#x27;</span><br>  ],<br>  <span class="hljs-attr">ext</span>: <span class="hljs-string">&#x27;js json&#x27;</span><br>&#125;);<br><br>nodemon.on(<span class="hljs-string">&#x27;start&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;mockServer has started&#x27;</span>);<br>&#125;).on(<span class="hljs-string">&#x27;quit&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;mockServer has quit&#x27;</span>);<br>  process.exit();<br>&#125;).on(<span class="hljs-string">&#x27;restart&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">files</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;mockServer restarted due to: &#x27;</span>, files);<br>&#125;);<br></code></pre></td></tr></table></figure><p>3、配置启动命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;serve&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node serve.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>到此已经完成，启动服务 npm run serve。这样你就重新添加了接口数据，服务会自动重新启动。</p><p>demo地址：<a href="https://github.com/Amosyue/mockServe]">https://github.com/Amosyue/mockServe]</a>(<a href="https://github.com/Amosyue/mockServe">https://github.com/Amosyue/mockServe</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>express</tag>
      
      <tag>mockjs</tag>
      
      <tag>nodemon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 提交之规范校验 (eslint+husky+prettier)</title>
    <link href="/2019/08/26/husky/"/>
    <url>/2019/08/26/husky/</url>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中为了统一团队编码规范，会用 Eslint 去检查和自动修复 js 代码。但是代码规范检查不通过，还是可以提交 commit 记录的，这显然是有问题的， 还好 git hook 提供了很多钩子函数绑定在 git 各个命令上，这样就可以把 eslint 代码检查放在 pre-commit hook 中， 这样如果eslint 检查不通过就不让提交了。</p></blockquote><h2 id="1、Git-hooks（git钩子）"><a href="#1、Git-hooks（git钩子）" class="headerlink" title="1、Git hooks（git钩子）"></a>1、Git hooks（git钩子）</h2><p>默认情况下项目中 .git&#x2F;hooks（.git文件夹下的hooks文件夹） 中已经内置了很多 hook，比如 pre-commit。如下图：</p><p><img src="/2019/08/26/husky/hook.webp" alt="pre-commit"><br>这些hooks文件夹下有很多git默认自带的钩子文件，这里我们主要使用pre-commit这个钩子文件。<br>我们找到.git&#x2F;hooks&#x2F;pre-commit文件，修改当前文件里的内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;我是测试pre-commit钩子命令的&#x27;</span><br></code></pre></td></tr></table></figure><p>然后在git 面板里执行git commit 命令，可以看到我们在执行git commit 命令时候触发了pre-commit钩子，输出了：’我是测试pre-commit钩子命令的’。如下图</p><p><img src="/2019/08/26/husky/commit.webp" alt="hook/pre-commit"><br>我们在.git&#x2F;hooks&#x2F;pre-commit文件里执行了输出一行字，那如果我们修改当然文件，让文件执行eslint校验，如下图<br><img src="/2019/08/26/husky/commit2.webp" alt="执行eslint校验"></p><p>注意.git&#x2F;hooks&#x2F;pre-commit文件里写 npm run eslint 那么一定要在package.json文件里添加如下代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;eslint&quot;</span>: <span class="hljs-string">&quot;eslint --ext .js,.vue zdyProject/&quot;</span> <span class="hljs-regexp">//</span>注意这个zdyProject/是我测试的文件目录，请根据自己代码自行修改<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里基本就完成了git提交时执行eslint校验功能了。但是在实际的团队项目里我们并不会这样做，因为我们是团队合作，.git&#x2F;hooks&#x2F;pre-commit文件修改后只会在本地，并不能上传到git上供其它成员使用，因为git会忽略.git文件夹下的文件。这个时候husky就可以解决这个问题。</p><h2 id="2、husky"><a href="#2、husky" class="headerlink" title="2、husky"></a>2、husky</h2><p>github为了解决.git配置不能提交远程仓库的问题，husky 出来了，husky 在你npm i安装完依赖只有自动执行husky install。</p><h6 id="2-1、安装husky"><a href="#2-1、安装husky" class="headerlink" title="2.1、安装husky"></a>2.1、安装husky</h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> husky -D<br></code></pre></td></tr></table></figure><h6 id="2-2、使用husky"><a href="#2-2、使用husky" class="headerlink" title="2.2、使用husky"></a>2.2、使用husky</h6><p>编辑package.json在script里添加prepare的值为husky install</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;prepare&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;husky install&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>然后执行npm run prepare，这个命令做了什么事呢 ？实际上就是创建 .husky 目录，修改了.git&#x2F;config文件里的hooksPath字段（设置 .husky 目录为 git hooks 目录）</p><p><img src="/2019/08/26/husky/commit3.webp" alt="eslint"></p><p>我们在.husky目录下创建一个pre-commit文件，里面放入代码 npm run eslint(如下图a)。</p><p>我们随便修改一下项目里的文件，然后执行git add .，git commit -m ‘测试husky’，发现代码已经被拦截，没有提交，因为index.vue代码不符合规范(效果如下图a)。<br><img src="/2019/08/26/husky/commit4.webp" alt="效果"><br>到这里husky的简单配置已经完成，但是试想一下有没有问题？，假如项目里有a.js，b.js文件，我修改了a.js，b.js文件，但是我执行了git add a.js(也就是只把a.js文件提到了git缓存)，那如果我们现在git commit 应该也只应该校验a.js才对，但是按照上面的配置，我们会在git commit的时候会校验的项目下的全部文件，这显然不对，也就是我们.husky目录下的pre-commit文件内容显然是不能够做到这样的，这时候就必须改写pre-commit文件内容，pre-commit文件是一个shell文件，对前端而言肯定是一大难题，不好写。这个时候就要用到lint-staged，用它来解决这个问题。</p><h6 id="3、lint-staged"><a href="#3、lint-staged" class="headerlink" title="3、lint-staged"></a>3、lint-staged</h6><p>lint-staged作用：对 Git 暂存区代码文件进行 bash 命令操作等等。<br>先安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i lint-staged -D<br></code></pre></td></tr></table></figure><p>package.json添加script</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;eslint&quot;</span>: <span class="hljs-string">&quot;lint-staged&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;*.&#123;js,vue&#125;&quot;</span>: [<br>      <span class="hljs-string">&quot;prettier --write&quot;</span>,<br>      <span class="hljs-string">&quot;eslint --ext .js,.vue&quot;</span><br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure><p>随便修改一下项目里a.js，b.js文件，然后执行git add a.js，git commit -m ‘test’，可以发现调用了 eslint 去检查代码，eslint只检查了a.js文件，并没有校验b.js文件。检查不通过就退出commit。如下图b</p><p><img src="/2019/08/26/husky/commit5.webp" alt="效果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>eslint</tag>
      
      <tag>husky</tag>
      
      <tag>prettier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多个前端项目中公共组件使用方案（npm包方式）</title>
    <link href="/2019/08/07/npmLink/"/>
    <url>/2019/08/07/npmLink/</url>
    
    <content type="html"><![CDATA[<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><blockquote><p>公司有多个前端项目，每个项目独立部署，各个项目里可能会使用相同的组件或者页面。对于这样的组件或者页面如何管理呢？我们可以把公共的组件或者页面抽离，单独存放在一个项目里，然后在其他项目里引入这个公共的项目</p></blockquote><h2 id="2、方案"><a href="#2、方案" class="headerlink" title="2、方案"></a>2、方案</h2><p>2.1 创建一个公共组件项目commonpack（名字自己定义），如下图</p><p><img src="/2019/08/07/npmLink/7579449-fe3d160bceb6079d.webp" alt="项目结构"></p><!--  --><p>outPages目录里是公共组件pageA和pageB，然后在根目录下创建index.js,向外暴露组件pageA和pageB。index.js文件里面代码如下</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> pageA <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./outPages/pageA&#x27;</span><br><span class="hljs-keyword">import</span> pageB <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./outPages/pageB&#x27;</span><br><span class="hljs-keyword">export</span> &#123;<br>  pageA,<br>  pageB<br>&#125;<br></code></pre></td></tr></table></figure><p>2.2 创建一个标准的前端项目packageone,packagetwo，那么packageone,packagetwo如何来引入公共组件项目commonpack里的组件pageA和pageB呢？有3个方案。</p><h6 id="方案一：npm发布引用"><a href="#方案一：npm发布引用" class="headerlink" title="方案一：npm发布引用"></a>方案一：npm发布引用</h6><p>公共组件项目commonpack的组件编写完成后，将其发布到npm。开发packageone,packagetwo的人员通过npm install命令将commonpack以node_module的方式引入</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install commonpack <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>另外，每次改动代码再次发布时，需要修改package.json文件中的版本号，不然发布不成功。<br>这种方法在开发阶段不便捷，改个公共组件，改完还得发包，发完后其他项目使用还得从新安装。</p><h6 id="方案二：npm-link"><a href="#方案二：npm-link" class="headerlink" title="方案二：npm link"></a>方案二：npm link</h6><p>首先进入commonpack包，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p>这会创建一个软连接，并保存到目录C:\Users\Administrator\AppData\Roaming\npm\node_modules下面。<br>然后进入packageone和packagetwo，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span> commonpack<br></code></pre></td></tr></table></figure><p>这就将这个公共的项目通过软连接的方式引入到项目里面来了。下图可以看到在node_modules中common包和其他的包文件夹样式是不一样的，common文件夹只是一个软链接。</p><p><img src="/2019/08/07/npmLink/common.webp" alt="软链接"></p><p>这时修改commonpack项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。<br>需要注意的是，当项目包依赖更新后，也就是执行了 npm install xxx 之后，需要重新link common项目。而且使用npm link后本地package.json里没有记录，无法直观的查看本地包的引用。</p><h6 id="方案三：npm本地file引用（推荐）"><a href="#方案三：npm本地file引用（推荐）" class="headerlink" title="方案三：npm本地file引用（推荐）"></a>方案三：npm本地file引用（推荐）</h6><p>分别进入packageone和packagetwo，在控制台输入命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install ..<span class="hljs-regexp">/commonpack/</span><br></code></pre></td></tr></table></figure><p>其中&#x2F;commonpack&#x2F;是commonpack的相对路径，这里也可以输入绝对路径。<br>这样就将commonpack这个工程以node_module的方式引入到packageone和packagetwo项目中了。可以正常使用commonpack在index.js中导出的组件了。<br>命令执行完后，package.json里会多一条记录<br><img src="/2019/08/07/npmLink/package.webp" alt="tupian123"></p><p>同样这时修改common项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。而且在package.json中有引入记录。</p><h6 id="3、举例"><a href="#3、举例" class="headerlink" title="3、举例"></a>3、举例</h6><p>我们在packageone项目里引入公共组件pageA和pageB</p><p><img src="/2019/08/07/npmLink/page1.webp" alt="组件引用"></p><h6 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h6><p><img src="/2019/08/07/npmLink/tu.webp" alt="效果图"></p><p>github项目地址：<a href="https://github.com/Amosyue/npmPackages">https://github.com/Amosyue/npmPackages</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>多个前端项目</tag>
      
      <tag>npm包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写 promise 方法之catch，finally方法</title>
    <link href="/2019/05/05/promiseMethods/"/>
    <url>/2019/05/05/promiseMethods/</url>
    
    <content type="html"><![CDATA[<blockquote><p>手写 promise 方法之catch，finally方法之前建议先阅读：<a href="/2019/05/01/writePromise/">手写promise方法</a>.</p></blockquote><p>需要注意，finally和catch方法只是then的一个别名，实际上返回的还是一个promise，完全可以这样写：promise.then().finally().then().catch().then()</p><h2 id="catch-方法"><a href="#catch-方法" class="headerlink" title="catch 方法"></a>catch 方法</h2><blockquote><p>catch 方法是 then 方法的语法糖，只接受 rejected 态的数据。既然catch 方法是 then 方法的语法糖，那么我们直接调用即可。我们把上一篇文章的代码拷贝一个简要的过来。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  <span class="hljs-keyword">static</span> pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  <span class="hljs-keyword">static</span> fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  <span class="hljs-keyword">static</span> rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-comment">//省略了代码，完整的看上一篇文章</span><br>  &#125;<br>  then = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">//then方法，这里省略，完整的看上一篇文章,这里现在看其实是有点问题，promise的then方法是定义在原型上，我这里这样写，等于是把then方法定义在实例对象上了。但是不影响，原理是一样的。</span><br>  &#125;<br>  <span class="hljs-comment">//catch方法定义在原型上</span><br>  <span class="hljs-keyword">catch</span>(onRejected)=&gt;&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,onRejected)<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="finally-方法"><a href="#finally-方法" class="headerlink" title="finally 方法"></a>finally 方法</h2><blockquote><p>finally() 方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。这避免了同样的语句需要在 then() 和 catch() 中各写一次的情况。注意此方法的回调函数中不接收任何参数。因此它仅用于无论最终结果如何都要执行的情况。如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，finally() 方法可能是有用的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  <span class="hljs-keyword">static</span> pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  <span class="hljs-keyword">static</span> fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  <span class="hljs-keyword">static</span> rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-comment">//省略了代码，完整的看上一篇文章</span><br>  &#125;<br>  then = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">//then方法，这里省略，完整的看上一篇文章</span><br>  &#125;<br>  onFinally = <span class="hljs-function">(<span class="hljs-params">onFinally</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(onFinally,onFinally)<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>原型链的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">Myfinally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-title function_">callback</span>()<br>    <span class="hljs-keyword">return</span> value<br>  &#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-title function_">callback</span>()<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>promise，手写promise</tag>
      
      <tag>catch，finally</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解promise原理之手写promise</title>
    <link href="/2019/05/01/writePromise/"/>
    <url>/2019/05/01/writePromise/</url>
    
    <content type="html"><![CDATA[<blockquote><p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。建议在看本文之前先大致浏览一遍 <a href="https://promisesaplus.com/" title="Promises/A+ 规范">Promises&#x2F;A+ 规范</a>，或许你更有收获。</p></blockquote><h2 id="1、基础版-Promise"><a href="#1、基础版-Promise" class="headerlink" title="1、基础版 Promise"></a>1、基础版 Promise</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Promise 执行函数是立即执行的&#x27;</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">2000</span>);<br>  <span class="hljs-comment">//resolve(1)</span><br>&#125;);<br>p.then(<br>  <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(val),<br>  err =&gt;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err)<br>);<br><span class="hljs-comment">// Promise 执行函数是立即执行的</span><br><span class="hljs-comment">// 1 （2 秒以后）</span><br></code></pre></td></tr></table></figure><p>从以上回顾可以看出：<br>1、Promise 是一个构造函数<br>2、new Promise 时候传入一个执行函数，此函数是立即执行的<br>3、执行函数接收 2 个参数，分别是 resolve 函数和 reject 函数，并且均能够接收参数<br>4、Promise 的实例上有 then 方法，then 方法接收 2 个参数</p><p>根据以上分析，可以简单的写出一个简易版的 promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  <span class="hljs-keyword">static</span> pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  <span class="hljs-keyword">static</span> fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  <span class="hljs-keyword">static</span> rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">Mypromise</span>.<span class="hljs-property">pending</span>;<span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">//成功结果</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    &#125;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>      <span class="hljs-title function_">reject</span>(e)<span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>promise&#x2F;A+规范中规定，当Promise对象已经由等待态（Pending）改变为执行态（Fulfilled）或者拒绝态（Rejected）后，就不能再次更改状态，且终值也不可改变。那么接下来我们来完善 resolve 和 reject 函数,</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  static pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  static fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  static rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-keyword">constructor</span>(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.pending;<span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-keyword">this</span>.value = undefined;<span class="hljs-comment">//成功结果</span><br>    <span class="hljs-keyword">this</span>.reason = undefined;<span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">const</span> resolve = (value)=&gt;&#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending )&#123;<br>        <span class="hljs-keyword">this</span>.value = value<br>        <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = (reason)=&gt;&#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending )&#123;<br>        <span class="hljs-keyword">this</span>.reason = reason<br>        <span class="hljs-keyword">this</span>.status = Mypromise.rejected <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      executor(resolve, reject);<span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>      reject(e)<span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、then方法实现"><a href="#2、then方法实现" class="headerlink" title="2、then方法实现"></a>2、then方法实现</h2><p>then方法,是这里比较复杂的功能；尤其注意：then方法特性<br>1、首先判断两个参数是否为函数类型，因为这两个参数是可选参数<br>2、当参数不是函数类型时，其必须被忽略,默认会创建一个函数赋值给对应的参数，同时也实现了透传.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  static pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  static fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  static rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-keyword">constructor</span>(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.pending;<span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-keyword">this</span>.value = undefined;<span class="hljs-comment">//成功结果</span><br>    <span class="hljs-keyword">this</span>.reason = undefined;<span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">const</span> resolve = (value)=&gt;&#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending )&#123;<br>        <span class="hljs-keyword">this</span>.value = value<br>        <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = (reason)=&gt;&#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending )&#123;<br>        <span class="hljs-keyword">this</span>.reason = reason<br>        <span class="hljs-keyword">this</span>.status = Mypromise.rejected <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      executor(resolve, reject);<span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>      reject(e)<span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>  then = (onFulfilled,onRejected)=&gt;&#123;<br>    onFulfilled = typeof onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : value =&gt; value<br>    onRejected = typeof onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : value =&gt; value<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending)&#123;<br>      onFulfilled(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.fulfilled)&#123;<br>      onFulfilled(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.rejected)&#123;<br>      onRejected(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里一个简单的promise已经基本实现，我们来测试一下。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  resolve(<span class="hljs-string">&#x27;张三&#x27;</span>)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data) <span class="hljs-comment">//输出张三</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的代码我们是直接resolve的值，可以理解是同步方法，那么我们我们使用下边的代码验证一下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;张三&#x27;</span>)<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(data)</span>=&gt;</span>&#123;<br>  console.log(data) <span class="hljs-regexp">//</span>期望是<span class="hljs-number">3</span>秒后输出：张三。可结果是直接输出undefind<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里then里面函数运行时，resolve函数是在定时器里，是异步执行的，还没有来得及修改status，此时还是pending状态,故结果肯定正确，因此我们需要对异步的情况做一下处理。</p><h2 id="3、then支持异步"><a href="#3、then支持异步" class="headerlink" title="3、then支持异步"></a>3、then支持异步</h2><p>那么如何让我们的Promise来支持异步呢？我们可以参考发布订阅模式，在执行then方法的时候，如果当前还是pending状态，就把回调函数寄存到一个数组中，当状态发生改变时，去数组中取出回调函数；因此我们先在Mypromise中定义一下变量：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(executor)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.fulfilledCallbacks = [] //成功的回调</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.rejectedCallbacks = [] //失败的回调</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p>then方法也改造一下如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">then</span> =<span class="hljs-function"> (<span class="hljs-params">onFulfilled</span>,<span class="hljs-params">onRejected</span>)=&gt;</span>&#123;<br>  onFulfilled = typeof onFulfilled<span class="hljs-operator"> === </span>&#x27;<span class="hljs-keyword">function</span>&#x27; ? onFulfilled :<span class="hljs-function"> <span class="hljs-params">value</span> =&gt;</span> value<br>  onRejected = typeof onRejected<span class="hljs-operator"> === </span>&#x27;<span class="hljs-keyword">function</span>&#x27; ? onRejected :<span class="hljs-function"> <span class="hljs-params">value</span> =&gt;</span> value<br>  <span class="hljs-comment">//当then执行时，如果还是pending状态，我们不是马上去执行回调函数，而是将其存储起来</span><br>  <span class="hljs-keyword">if</span>(this.status<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Mypromise</span>.</span></span>pending)&#123;<br>    this.fulfilledCallbacks.push(onFulfilled)<br>  &#125;<br>  <span class="hljs-keyword">if</span>(this.status<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Mypromise</span>.</span></span>fulfilled)&#123;<br>    on<span class="hljs-constructor">Fulfilled(<span class="hljs-params">this</span>.<span class="hljs-params">value</span>)</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(this.status<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Mypromise</span>.</span></span>rejected)&#123;<br>    on<span class="hljs-constructor">Rejected(<span class="hljs-params">this</span>.<span class="hljs-params">value</span>)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>存储起来后，当resolve或者reject异步执行的时候就可以来调用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>  <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled; <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>    <span class="hljs-comment">//调用存储起来的成功方法</span><br>    <span class="hljs-keyword">this</span>.fulfilledCallbacks.forEach(cb=&gt;cb(<span class="hljs-keyword">this</span>.value))<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>  <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>    <span class="hljs-keyword">this</span>.reason = reason;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.rejected; <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>    <span class="hljs-comment">//调用存储起来的失败方法</span><br>    <span class="hljs-keyword">this</span>.rejectedCallbacks.forEach(cb=&gt;cb(<span class="hljs-keyword">this</span>.reason))<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  static pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  static fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  static rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-keyword">constructor</span>(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.pending; <span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-keyword">this</span>.value = undefined; <span class="hljs-comment">//成功结果</span><br>    <span class="hljs-keyword">this</span>.reason = undefined; <span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">this</span>.fulfilledCallbacks = [] <span class="hljs-comment">//成功的回调</span><br>    <span class="hljs-keyword">this</span>.rejectedCallbacks = [] <span class="hljs-comment">//失败的回调</span><br>    <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled; <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>        <span class="hljs-keyword">this</span>.fulfilledCallbacks.forEach(cb=&gt;cb(<span class="hljs-keyword">this</span>.value))<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>        <span class="hljs-keyword">this</span>.status = Mypromise.rejected; <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>        <span class="hljs-keyword">this</span>.rejectedCallbacks.forEach(cb=&gt;cb(<span class="hljs-keyword">this</span>.reason))<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor(resolve, reject); <span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e); <span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>  then = (onFulfilled,onRejected)=&gt;&#123;<br>    onFulfilled = typeof onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : value =&gt; value<br>    onRejected = typeof onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : value =&gt; value<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending)&#123;<br>      <span class="hljs-keyword">this</span>.fulfilledCallbacks.push(onFulfilled)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.fulfilled)&#123;<br>      onFulfilled(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.rejected)&#123;<br>      onRejected(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在测试一下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;张三&#x27;</span>)<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(data)</span>=&gt;</span>&#123;<br>  console.log(data) //<span class="hljs-number">3</span>秒后输出：张三。表明<span class="hljs-keyword">then</span>异步方法改造成功。<br>&#125;)<br></code></pre></td></tr></table></figure><p>到此我们写的Mypromise方法已经可以简单使用了，距离成功又近了一步。但是多个then的时候就出现了问题，比如:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;张三&#x27;</span>)<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data) <span class="hljs-comment">//3秒后输出：张三。表明then异步方法改造成功。</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码第二个then会报错，看来我们还得继续努力，但是别急，我们一步步来，肯定可以成功！下边我们就来逐步完善缺失的功能。</p><h2 id="4、then链式调用"><a href="#4、then链式调用" class="headerlink" title="4、then链式调用"></a>4、then链式调用</h2><p>promise&#x2F;A+规范中规定：</p><blockquote><p>then 方法必须返回一个 promise 对象<br>promise2 &#x3D; promise1.then(onFulfilled, onRejected);<br>也就是说，每个then方法都要返回一个新的Promise对象，这样我们的then方法才能不断的链式调用；因此上面then方法就不适用了，因为它什么都没有返回，我们对其进行简单的改写，不论then进行什么操作，都返回一个新的Promise对象,新的then方法是如下格式。</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">then = <span class="hljs-function">(<span class="hljs-params">onFulfilled,onRejected</span>)=&gt;</span>&#123;<br>  onFulfilled = <span class="hljs-built_in">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value<br>  onRejected = <span class="hljs-built_in">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value<br>  <span class="hljs-keyword">var</span> promise2 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br><br>  &#125;)<br>  <span class="hljs-keyword">return</span> promise2<br>&#125;<br></code></pre></td></tr></table></figure><p>then的执行过程：</p><p>1、如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)<br>2、如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e<br>3、如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值<br>4、如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的原因</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title">then</span> = <span class="hljs-params">(onFulfilled, onRejected)</span> =&gt;</span> &#123;<br>  onFulfilled =<br>    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> value;<br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> value;<br>  <br>  var promise2 = <span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (this.status === Mypromise.pending) &#123;<br>      <span class="hljs-regexp">//</span>传入的函数的函数体需要异步执行，这是规范规定的<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        this.fulfilledCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>          let x = onFulfilled(this.value);<br>          this.resolvePromise(promise2, x, resolve, reject);<br>        &#125;);<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (this.status === Mypromise.fulfilled) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        let x = onFulfilled(this.value);<br>        this.resolvePromise(promise2, x, resolve, reject);<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (this.status === Mypromise.rejected) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        let x = onFulfilled(this.reason);<br>        this.resolvePromise(promise2, x, resolve, reject);<br>      &#125;)<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise2;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>首先我们返回了一个新的 Promise 对象，并在 Promise 中传入了一个函数<br>函数的基本逻辑还是和之前一样，往回调数组中 push 函数<br>同样，在执行函数的过程中可能会遇到错误，所以使用了 try…catch 包裹<br>规范规定，执行 onFulfilled 或者 onRejected 函数时会返回一个 x，并且执行 Promise 解决过程，这是为了不同的 Promise 都可以兼容使用，比如 JQuery 的 Promise 能兼容 ES6 的 Promise 接下来我们改造判断执行态的逻辑</p></blockquote><h2 id="5、resolvePromise的实现"><a href="#5、resolvePromise的实现" class="headerlink" title="5、resolvePromise的实现"></a>5、resolvePromise的实现</h2><p>首先规范规定了 x 不能与 promise2 相等，这样会发生循环引用的问题，比如如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p1 = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> p1<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以resolvePromise函数第一步就会校验promise2 是否等于 x</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title">resolvePromise</span> = <span class="hljs-params">(promise2, x, resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不允许操作&#x27;</span>));<br>  &#125;<br></code></pre></td></tr></table></figure><p>完整的resolvePromise函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript">resolvePromise = <span class="hljs-function">(<span class="hljs-params">promise2, x, resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;不能循环引用&#x27;</span>));<br>  &#125;<br>  <span class="hljs-comment">//promise/A+ 规范2.3.2规定如果x是一个promise，采用它的状态 .</span><br>  <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Mypromise</span>)&#123;<br>    <span class="hljs-keyword">if</span>(x.<span class="hljs-property">status</span> === <span class="hljs-title class_">Mypromise</span>.<span class="hljs-property">pending</span>)&#123;<br>      x.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>)&#123;<br>        <span class="hljs-comment">// 递归下去，直到遇到第一个非promise，promise2就会解决/拒绝</span><br>        <span class="hljs-title function_">resolvePromise</span>(promise2,y,resolve,reject)<br>      &#125;,reject)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      x.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//promise/A+ 规范2.3.3 如果x是一个对象或函数</span><br>  <span class="hljs-keyword">if</span> ((x &amp;&amp; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> used; <span class="hljs-comment">//premose2是否已经resolve或者reject,按规定promise的resolve，reject只能调用一次。</span><br>    <span class="hljs-comment">//这里处理的是我们写的Mypromise与别人写的promise对象做交互的情况，经可能的考虑兼容性，考虑到别人乱写promise的情况。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">let</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>            used = <span class="hljs-literal">true</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>            used = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;,<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>        used = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>      used = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//x是一个普通的值</span><br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>到这里以及完成了resolvePromise方法。</p><p>下边就是完整的Mypromise方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  static pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  static fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  static rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-keyword">constructor</span>(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.pending; <span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-keyword">this</span>.value = undefined; <span class="hljs-comment">//成功结果</span><br>    <span class="hljs-keyword">this</span>.reason = undefined; <span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">this</span>.fulfilledCallbacks = []; <span class="hljs-comment">//成功的回调</span><br>    <span class="hljs-keyword">this</span>.rejectedCallbacks = []; <span class="hljs-comment">//失败的回调</span><br>    <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled; <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>        <span class="hljs-keyword">this</span>.fulfilledCallbacks.forEach((cb) =&gt; cb(<span class="hljs-keyword">this</span>.value));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>        <span class="hljs-keyword">this</span>.status = Mypromise.rejected; <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>        <span class="hljs-keyword">this</span>.rejectedCallbacks.forEach((cb) =&gt; cb(<span class="hljs-keyword">this</span>.reason));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor(resolve, reject); <span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e); <span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>  then = (onFulfilled, onRejected) =&gt; &#123;<br>    onFulfilled =<br>      typeof onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : (value) =&gt; value;<br>    onRejected =<br>      typeof onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : (value) =&gt; value;<br><br>    <span class="hljs-keyword">var</span> promise2 = new Mypromise((resolve, reject) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.fulfilledCallbacks.push(() =&gt; &#123;<br>          let x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>          <span class="hljs-keyword">this</span>.resolvePromise(promise2, x, resolve, reject);<br>        &#125;);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.fulfilled) &#123;<br>        <span class="hljs-comment">// onFulfilled(this.value);</span><br>        let x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        <span class="hljs-keyword">this</span>.resolvePromise(promise2, x, resolve, reject);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.rejected) &#123;<br>        <span class="hljs-comment">// onRejected(this.value);</span><br>        let x = onFulfilled(<span class="hljs-keyword">this</span>.reason);<br>        <span class="hljs-keyword">this</span>.resolvePromise(promise2, x, resolve, reject);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>  resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>      reject(new TypeError(<span class="hljs-string">&#x27;不能循环引用&#x27;</span>));<br>    &#125;<br>    <span class="hljs-comment">//promise/A+ 规范2.3.2规定如果x是一个promise，采用它的状态 .</span><br>    <span class="hljs-keyword">if</span>(x instanceof Mypromise)&#123;<br>      <span class="hljs-keyword">if</span>(x.status === Mypromise.pending)&#123;<br>        x.then(function(y)&#123;<br>          <span class="hljs-comment">// 递归下去，直到遇到第一个非promise，promise2就会解决/拒绝</span><br>          resolvePromise(promise2,y,resolve,reject)<br>        &#125;,reject)<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        x.then(resolve, reject);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//promise/A+ 规范2.3.3 如果x是一个对象或函数</span><br>    <span class="hljs-keyword">if</span> ((x &amp;&amp; typeof x === <span class="hljs-string">&#x27;object&#x27;</span>) || typeof x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      let used; <span class="hljs-comment">//premose2是否已经resolve或者reject,按规定promise的resolve，reject只能调用一次。</span><br>      <span class="hljs-comment">//这里处理的是我们写的Mypromise与别人写的promise对象做交互的情况，经可能的考虑兼容性，考虑到别人乱写promise的情况。</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        let then = x.then;<br>        <span class="hljs-keyword">if</span> (typeof then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          then.call(<br>            x,<br>            (y) =&gt; &#123;<br>              <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>              used = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">this</span>.resolvePromise(promise2, y, resolve, reject);<br>            &#125;,<br>            (r) =&gt; &#123;<br>              <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>              used = <span class="hljs-literal">true</span>;<br>              reject(r);<br>            &#125;,<br>          );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>          used = <span class="hljs-literal">true</span>;<br>          resolve(x);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>        used = <span class="hljs-literal">true</span>;<br>        reject(e);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//普通的值的情况</span><br>      resolve(x);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>promise，手写promise</tag>
      
      <tag>resolvePromise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数防抖（debounce）和函数节流（throttle）解析</title>
    <link href="/2019/02/10/debounceAndthrottle/"/>
    <url>/2019/02/10/debounceAndthrottle/</url>
    
    <content type="html"><![CDATA[<!-- >他们有什么用？我们什么时候才会用到他们？ --><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><p>本质上都是优化高频率执行代码的一种手段。</p><p>如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><blockquote><p><font color="red">触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间</font></p></blockquote><h5 id="常见的应用场景"><a href="#常见的应用场景" class="headerlink" title="常见的应用场景"></a>常见的应用场景</h5><p>1、input框输入。只需要用户最后一次输入完再发送请求<br>2、手机号、邮箱格式的输入验证检测。<br>3、窗口大小的 resize 。只需窗口调整完成后，计算窗口的大小，防止重复渲染。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>先来个简单版本的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">fn, delayTime</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer)<br>    &#125;<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span>&#123;<br>      <span class="hljs-comment">//改变this的指向</span><br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, delayTime)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个就是防抖的最常用实现，但是我们看看代码你是否发现了一个问题？那就一次触发也要等待延迟了才会触发，如果我有个场景想第一次就立即触发，这个时候上面的代码是不满足的，那我们就需要对这个函数改造如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">fn, delayTime,immediate = <span class="hljs-literal">false</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(immediate &amp;&amp; !timer)&#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span>&#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, delayTime)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// let box = document.getElementById(&#x27;box&#x27;)</span><br><span class="hljs-comment">// box.onmousemove = debounce(function()&#123;</span><br><span class="hljs-comment">//  console.log(&quot;成功&quot;)</span><br><span class="hljs-comment">// &#125;，1000,true)</span><br></code></pre></td></tr></table></figure><p>在思考下，如果有一种场景，我触发了防抖事件，但是在延迟的时间内我后悔了，这时候我想取消防抖事件，那又该如何做呢？很简单，我们添加个取消事件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">fn, delayTime,immediate = <span class="hljs-literal">false</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">let</span> debounced = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(immediate &amp;&amp; !timer)&#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span>&#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, delayTime)<br>  &#125;<br>  debounced.<span class="hljs-property">cancle</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br>  &#125;<br>  <span class="hljs-keyword">return</span> debounced<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><blockquote><p><font color="red">规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。.</font><br>实现方法有好几种，我们一个个的实现</p></blockquote><h5 id="1、时间戳方式实现"><a href="#1、时间戳方式实现" class="headerlink" title="1、时间戳方式实现"></a>1、时间戳方式实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">fn,delayTime</span>)=&gt;&#123;<br>  <span class="hljs-keyword">var</span> old = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <span class="hljs-keyword">const</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    <span class="hljs-keyword">if</span>(now - old &gt; delayTime)&#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args)<br>      old = now<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//此方法实现的特点是：第一次会立即执行，最后一次事件不执行</span><br></code></pre></td></tr></table></figure><h5 id="2、定时器方式实现"><a href="#2、定时器方式实现" class="headerlink" title="2、定时器方式实现"></a>2、定时器方式实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">fn,delayTime</span>)=&gt;&#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <span class="hljs-keyword">if</span>(!timer)&#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span>&#123;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;,delayTime)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//此方法实现的特点是：第一次会延迟执行，最后一次事件停止后也会执行</span><br></code></pre></td></tr></table></figure><h5 id="3、时间戳-定时器方式实现"><a href="#3、时间戳-定时器方式实现" class="headerlink" title="3、时间戳+定时器方式实现"></a>3、时间戳+定时器方式实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">fn,delayTime</span>)=&gt;&#123;<br>  <span class="hljs-keyword">var</span> old = <span class="hljs-number">0</span>,timer<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    <span class="hljs-keyword">if</span>(now - old &gt; delayTime)&#123;<br>      <span class="hljs-keyword">if</span>(timer)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args)<br>      old = now<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!timer)&#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span>&#123;<br>        old = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;,delayTime)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//此方法实现的特点是：第一次会立即执行，最后一次事件停止后也会执行</span><br></code></pre></td></tr></table></figure><h5 id="4、节流的优化"><a href="#4、节流的优化" class="headerlink" title="4、节流的优化"></a>4、节流的优化</h5><p>如果我想写一个节流方法，通过配置可以实现上面3种形式，如何处理呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">fn,delayTime,options=&#123;&#125;</span>)=&gt;&#123;<br>  <span class="hljs-keyword">var</span> old = <span class="hljs-number">0</span>,timer<br>  <span class="hljs-comment">//默认 options = &#123;</span><br>  <span class="hljs-comment">//   leading:true,//立即执行</span><br>  <span class="hljs-comment">//   trailing:true //最后一次也执行</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    <span class="hljs-keyword">if</span>(options.<span class="hljs-property">leading</span> === <span class="hljs-literal">false</span>)&#123;<br>      old = now<br>    &#125;<br>    <span class="hljs-keyword">if</span>(now - old &gt; delayTime)&#123;<br>      <span class="hljs-keyword">if</span>(timer)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args)<br>      old = now<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!timer &amp;&amp; options.<span class="hljs-property">trailing</span> !== <span class="hljs-literal">false</span>)&#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span>&#123;<br>        old = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;,delayTime)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
