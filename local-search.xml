<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>markdown</title>
    <link href="/2022/07/22/markdown/"/>
    <url>/2022/07/22/markdown/</url>
    
    <content type="html"><![CDATA[<p>语法地址：<a href="https://docs.github.com/cn/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">https://docs.github.com/cn/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax</a></p><p><a href="https://keatonlao.gitee.io/a-study-note-for-markdown/syntax/">https://keatonlao.gitee.io/a-study-note-for-markdown/syntax/</a></p><h1 id="最大标题"><a href="#最大标题" class="headerlink" title="最大标题"></a>最大标题</h1><h2 id="第二大标题"><a href="#第二大标题" class="headerlink" title="第二大标题"></a>第二大标题</h2><h6 id="最小标题"><a href="#最小标题" class="headerlink" title="最小标题"></a>最小标题</h6><p>这个是引用的格式</p><blockquote><p>Text that is a quote</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">这个是应用的格式<br>&gt; Text <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> a <span class="hljs-literal">quote</span><br><br></code></pre></td></tr></table></figure><p><font color="red">我是红色</font><br><font color="#008000">我是绿色</font></p><div bgcolor="yellow">背景是黄色</div><table><tr><td bgcolor="yellow">背景色yellow</td></tr></table><center>文字居中</center><p>####小坦克</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git 提交之规范校验 (eslint+husky+prettier)</title>
    <link href="/2019/08/26/husky/"/>
    <url>/2019/08/26/husky/</url>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中为了统一团队编码规范，会用 Eslint 去检查和自动修复 js 代码。但是代码规范检查不通过，还是可以提交 commit 记录的，这显然是有问题的， 还好 git hook 提供了很多钩子函数绑定在 git 各个命令上，这样就可以把 eslint 代码检查放在 pre-commit hook 中， 这样如果eslint 检查不通过就不让提交了。</p></blockquote><h2 id="1、Git-hooks（git钩子）"><a href="#1、Git-hooks（git钩子）" class="headerlink" title="1、Git hooks（git钩子）"></a>1、Git hooks（git钩子）</h2><p>默认情况下项目中 .git&#x2F;hooks（.git文件夹下的hooks文件夹） 中已经内置了很多 hook，比如 pre-commit。如下图：</p><p><img src="/2019/08/26/husky/hook.webp" alt="项目结构"><br>这些hooks文件夹下有很多git默认自带的钩子文件，这里我们主要使用pre-commit这个钩子文件。<br>我们找到.git&#x2F;hooks&#x2F;pre-commit文件，修改当前文件里的内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;我是测试pre-commit钩子命令的&#x27;</span><br></code></pre></td></tr></table></figure><p>然后在git 面板里执行git commit 命令，可以看到我们在执行git commit 命令时候触发了pre-commit钩子，输出了：’我是测试pre-commit钩子命令的’。如下图</p><p><img src="/2019/08/26/husky/commit.webp" alt="项目结构"><br>我们在.git&#x2F;hooks&#x2F;pre-commit文件里执行了输出一行字，那如果我们修改当然文件，让文件执行eslint校验，如下图<br><img src="/2019/08/26/husky/commit2.webp" alt="项目结构"></p><p>注意.git&#x2F;hooks&#x2F;pre-commit文件里写 npm run eslint 那么一定要在package.json文件里添加如下代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;eslint&quot;</span>: <span class="hljs-string">&quot;eslint --ext .js,.vue zdyProject/&quot;</span> <span class="hljs-regexp">//</span>注意这个zdyProject/是我测试的文件目录，请根据自己代码自行修改<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里基本就完成了git提交时执行eslint校验功能了。但是在实际的团队项目里我们并不会这样做，因为我们是团队合作，.git&#x2F;hooks&#x2F;pre-commit文件修改后只会在本地，并不能上传到git上供其它成员使用，因为git会忽略.git文件夹下的文件。这个时候husky就可以解决这个问题。</p><h2 id="2、husky"><a href="#2、husky" class="headerlink" title="2、husky"></a>2、husky</h2><p>github为了解决.git配置不能提交远程仓库的问题，husky 出来了，husky 在你npm i安装完依赖只有自动执行husky install。</p><h6 id="2-1、安装husky"><a href="#2-1、安装husky" class="headerlink" title="2.1、安装husky"></a>2.1、安装husky</h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> husky -D<br></code></pre></td></tr></table></figure><h6 id="2-2、使用husky"><a href="#2-2、使用husky" class="headerlink" title="2.2、使用husky"></a>2.2、使用husky</h6><p>编辑package.json在script里添加prepare的值为husky install</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;prepare&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;husky install&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>然后执行npm run prepare，这个命令做了什么事呢 ？实际上就是创建 .husky 目录，修改了.git&#x2F;config文件里的hooksPath字段（设置 .husky 目录为 git hooks 目录）</p><p><img src="/2019/08/26/husky/commit3.webp" alt="项目结构"></p><p>我们在.husky目录下创建一个pre-commit文件，里面放入代码 npm run eslint(如下图a)。</p><p>我们随便修改一下项目里的文件，然后执行git add .，git commit -m ‘测试husky’，发现代码已经被拦截，没有提交，因为index.vue代码不符合规范(效果如下图a)。<br><img src="/2019/08/26/husky/commit4.webp" alt="项目结构"><br>到这里husky的简单配置已经完成，但是试想一下有没有问题？，假如项目里有a.js，b.js文件，我修改了a.js，b.js文件，但是我执行了git add a.js(也就是只把a.js文件提到了git缓存)，那如果我们现在git commit 应该也只应该校验a.js才对，但是按照上面的配置，我们会在git commit的时候会校验的项目下的全部文件，这显然不对，也就是我们.husky目录下的pre-commit文件内容显然是不能够做到这样的，这时候就必须改写pre-commit文件内容，pre-commit文件是一个shell文件，对前端而言肯定是一大难题，不好写。这个时候就要用到lint-staged，用它来解决这个问题。</p><h6 id="3、lint-staged"><a href="#3、lint-staged" class="headerlink" title="3、lint-staged"></a>3、lint-staged</h6><p>lint-staged作用：对 Git 暂存区代码文件进行 bash 命令操作等等。<br>先安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i lint-staged -D<br></code></pre></td></tr></table></figure><p>package.json添加script</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;eslint&quot;</span>: <span class="hljs-string">&quot;lint-staged&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;*.&#123;js,vue&#125;&quot;</span>: [<br>      <span class="hljs-string">&quot;prettier --write&quot;</span>,<br>      <span class="hljs-string">&quot;eslint --ext .js,.vue&quot;</span><br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure><p>随便修改一下项目里a.js，b.js文件，然后执行git add a.js，git commit -m ‘test’，可以发现调用了 eslint 去检查代码，eslint只检查了a.js文件，并没有校验b.js文件。检查不通过就退出commit。如下图b</p><p><img src="/2019/08/26/husky/commit5.webp" alt="项目结构"></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>eslint</tag>
      
      <tag>husky</tag>
      
      <tag>prettier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多个前端项目中公共组件使用方案（npm包方式）</title>
    <link href="/2019/08/07/npmLink/"/>
    <url>/2019/08/07/npmLink/</url>
    
    <content type="html"><![CDATA[<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><blockquote><p>公司有多个前端项目，每个项目独立部署，各个项目里可能会使用相同的组件或者页面。对于这样的组件或者页面如何管理呢？我们可以把公共的组件或者页面抽离，单独存放在一个项目里，然后在其他项目里引入这个公共的项目</p></blockquote><h2 id="2、方案"><a href="#2、方案" class="headerlink" title="2、方案"></a>2、方案</h2><p>2.1 创建一个公共组件项目commonpack（名字自己定义），如下图</p><p><img src="/2019/08/07/npmLink/7579449-fe3d160bceb6079d.webp" alt="项目结构"></p><!--  --><p>outPages目录里是公共组件pageA和pageB，然后在根目录下创建index.js,向外暴露组件pageA和pageB。index.js文件里面代码如下</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> pageA <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./outPages/pageA&#x27;</span><br><span class="hljs-keyword">import</span> pageB <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./outPages/pageB&#x27;</span><br><span class="hljs-keyword">export</span> &#123;<br>  pageA,<br>  pageB<br>&#125;<br></code></pre></td></tr></table></figure><p>2.2 创建一个标准的前端项目packageone,packagetwo，那么packageone,packagetwo如何来引入公共组件项目commonpack里的组件pageA和pageB呢？有3个方案。</p><h6 id="方案一：npm发布引用"><a href="#方案一：npm发布引用" class="headerlink" title="方案一：npm发布引用"></a>方案一：npm发布引用</h6><p>公共组件项目commonpack的组件编写完成后，将其发布到npm。开发packageone,packagetwo的人员通过npm install命令将commonpack以node_module的方式引入</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install commonpack <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>另外，每次改动代码再次发布时，需要修改package.json文件中的版本号，不然发布不成功。<br>这种方法在开发阶段不便捷，改个公共组件，改完还得发包，发完后其他项目使用还得从新安装。</p><h6 id="方案二：npm-link"><a href="#方案二：npm-link" class="headerlink" title="方案二：npm link"></a>方案二：npm link</h6><p>首先进入commonpack包，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p>这会创建一个软连接，并保存到目录C:\Users\Administrator\AppData\Roaming\npm\node_modules下面。<br>然后进入packageone和packagetwo，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span> commonpack<br></code></pre></td></tr></table></figure><p>这就将这个公共的项目通过软连接的方式引入到项目里面来了。下图可以看到在node_modules中common包和其他的包文件夹样式是不一样的，common文件夹只是一个软链接。</p><p><img src="/2019/08/07/npmLink/common.webp" alt="软链接"></p><p>这时修改commonpack项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。<br>需要注意的是，当项目包依赖更新后，也就是执行了 npm install xxx 之后，需要重新link common项目。而且使用npm link后本地package.json里没有记录，无法直观的查看本地包的引用。</p><h6 id="方案三：npm本地file引用（推荐）"><a href="#方案三：npm本地file引用（推荐）" class="headerlink" title="方案三：npm本地file引用（推荐）"></a>方案三：npm本地file引用（推荐）</h6><p>分别进入packageone和packagetwo，在控制台输入命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install ..<span class="hljs-regexp">/commonpack/</span><br></code></pre></td></tr></table></figure><p>其中&#x2F;commonpack&#x2F;是commonpack的相对路径，这里也可以输入绝对路径。<br>这样就将commonpack这个工程以node_module的方式引入到packageone和packagetwo项目中了。可以正常使用commonpack在index.js中导出的组件了。<br>命令执行完后，package.json里会多一条记录<br><img src="/2019/08/07/npmLink/package.webp" alt="tupian123"></p><p>同样这时修改common项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。而且在package.json中有引入记录。</p><h6 id="3、举例"><a href="#3、举例" class="headerlink" title="3、举例"></a>3、举例</h6><p>我们在packageone项目里引入公共组件pageA和pageB</p><p><img src="/2019/08/07/npmLink/page1.webp" alt="组件引用"></p><h6 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h6><p><img src="/2019/08/07/npmLink/tu.webp" alt="效果图"></p><p>github项目地址：<a href="https://github.com/Amosyue/npmPackages">https://github.com/Amosyue/npmPackages</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>多个前端项目</tag>
      
      <tag>npm包</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
