<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/23/settimeout/"/>
    <url>/2022/08/23/settimeout/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown</title>
    <link href="/2022/07/22/markdown/"/>
    <url>/2022/07/22/markdown/</url>
    
    <content type="html"><![CDATA[<p>语法地址：<a href="https://docs.github.com/cn/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">https://docs.github.com/cn/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax</a></p><p><a href="https://keatonlao.gitee.io/a-study-note-for-markdown/syntax/">https://keatonlao.gitee.io/a-study-note-for-markdown/syntax/</a></p><h1 id="最大标题"><a href="#最大标题" class="headerlink" title="最大标题"></a>最大标题</h1><h2 id="第二大标题"><a href="#第二大标题" class="headerlink" title="第二大标题"></a>第二大标题</h2><h6 id="最小标题"><a href="#最小标题" class="headerlink" title="最小标题"></a>最小标题</h6><p>这个是引用的格式</p><blockquote><p>Text that is a quote</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">这个是应用的格式<br>&gt; Text <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> a <span class="hljs-literal">quote</span><br><br></code></pre></td></tr></table></figure><p><font color="red">我是红色</font><br><font color="#008000">我是绿色</font></p><div bgcolor="yellow">背景是黄色</div><table><tr><td bgcolor="yellow">背景色yellow</td></tr></table><center>文字居中</center><p>####小坦克</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>express+mockjs+nodemon 搭建一个mock服务</title>
    <link href="/2019/10/23/mock/"/>
    <url>/2019/10/23/mock/</url>
    
    <content type="html"><![CDATA[<blockquote><p>express+mockjs+nodemon 搭建一个mock服务，方便前端开发 (demo已经上传到github，地址：<a href="https://github.com/Amosyue/mockServe">https://github.com/Amosyue/mockServe</a></p></blockquote><h2 id="使用mockjs的方式"><a href="#使用mockjs的方式" class="headerlink" title="使用mockjs的方式"></a>使用mockjs的方式</h2><p>1、在项目入口文件中直接引入配置好的mock文件</p><p>这种方法需要在项目内引入mock并创建相关配置文件，根据环境来配置，代码耦合度太高</p><p>2、配合express启一个服务</p><p>这样就相当于模拟了真实的接口，netWork可以看到请求，并且可以不在该项目中做任何配置直接向服务发起请求即可。<br>这里我们只说下第二种情况，这样项目和mock数据分离，需要mock数据的时候只需要启动本地mock服务即可，代码耦合度低。</p><p>实例操作配置</p><p>1、安装express,mockjs</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> express mockjs <span class="hljs-attr">--save-dev</span><br></code></pre></td></tr></table></figure><p>2、在项目的根目录创建index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)(); <span class="hljs-comment">//实例化express</span><br><span class="hljs-comment">// 代理部分请求</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/proxy/lanmu1/test2&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;post /lanmu1/test2&#x27;</span>)<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;token string&#x27;</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;mock-server：模拟数据&#x27;</span><br>  &#125;)<br>&#125;);<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/mock/api&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-comment">// mockjs中属性名‘|’符号后面的属性为随机属性，数组对象后面的随机属性为随机数组数量，正则表达式表示随机规则，+1代表自增</span><br>  res.<span class="hljs-title function_">json</span>(&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&#x27;ss999999&#x27;</span>&#125;);<br>&#125;);<br><span class="hljs-comment">// 监听3001端口</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;3001&#x27;</span>);<br></code></pre></td></tr></table></figure><p>3、设置启动命令</p><p>如果不设置启动命令，那么此步骤可省略。启动命令默认是 node index.js.<br>如果配置启动命令如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这样只需要npm run mock就可以了<br>到这里其实简单的mock服务已经配置好了，运行npm run mock，项目就可以启动了，你可以在其他项目中调用你写在mock服务里的接口了。</p><p>4、配置nodemon</p><p>到第3步，其实已经配置好了，但是有个小问题，如果你添加或者删除了默写数据接口，你必须重启服务，没有热更新，这步就是为了解决这个问题。</p><p>1、安装nodemon</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> nodemon  <span class="hljs-attr">--save-dev</span><br></code></pre></td></tr></table></figure><p>2、在根目录创建serve.js</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> nodemon = require(<span class="hljs-string">&#x27;nodemon&#x27;</span>); <span class="hljs-comment">//引入nodemon模块</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * script 重启的脚本</span><br><span class="hljs-comment"> * ext 检测的文件类型</span><br><span class="hljs-comment"> * watch 监听哪些文件，文件夹，如果配置此字段，那么nodemon就会匹配当前字段下的文件</span><br><span class="hljs-comment"> * ignore 忽略哪些文件</span><br><span class="hljs-comment"> */</span><br>nodemon(&#123;<br>  <span class="hljs-attr">script</span>: <span class="hljs-string">&#x27;./index.js&#x27;</span>,<br>  <span class="hljs-attr">ignore</span>:[],<br>  <span class="hljs-attr">watch</span>: [<br>    <span class="hljs-string">&#x27;api/&#x27;</span>,<br>    <span class="hljs-string">&#x27;index.js&#x27;</span><br>  ],<br>  <span class="hljs-attr">ext</span>: <span class="hljs-string">&#x27;js json&#x27;</span><br>&#125;);<br><br>nodemon.on(<span class="hljs-string">&#x27;start&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;mockServer has started&#x27;</span>);<br>&#125;).on(<span class="hljs-string">&#x27;quit&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;mockServer has quit&#x27;</span>);<br>  process.exit();<br>&#125;).on(<span class="hljs-string">&#x27;restart&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">files</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;mockServer restarted due to: &#x27;</span>, files);<br>&#125;);<br></code></pre></td></tr></table></figure><p>3、配置启动命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;serve&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node serve.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>到此已经完成，启动服务 npm run serve。这样你就重新添加了接口数据，服务会自动重新启动。</p><p>demo地址：<a href="https://github.com/Amosyue/mockServe]">https://github.com/Amosyue/mockServe]</a>(<a href="https://github.com/Amosyue/mockServe">https://github.com/Amosyue/mockServe</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>express</tag>
      
      <tag>mockjs</tag>
      
      <tag>nodemon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 提交之规范校验 (eslint+husky+prettier)</title>
    <link href="/2019/08/26/husky/"/>
    <url>/2019/08/26/husky/</url>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中为了统一团队编码规范，会用 Eslint 去检查和自动修复 js 代码。但是代码规范检查不通过，还是可以提交 commit 记录的，这显然是有问题的， 还好 git hook 提供了很多钩子函数绑定在 git 各个命令上，这样就可以把 eslint 代码检查放在 pre-commit hook 中， 这样如果eslint 检查不通过就不让提交了。</p></blockquote><h2 id="1、Git-hooks（git钩子）"><a href="#1、Git-hooks（git钩子）" class="headerlink" title="1、Git hooks（git钩子）"></a>1、Git hooks（git钩子）</h2><p>默认情况下项目中 .git&#x2F;hooks（.git文件夹下的hooks文件夹） 中已经内置了很多 hook，比如 pre-commit。如下图：</p><p><img src="/2019/08/26/husky/hook.webp" alt="pre-commit"><br>这些hooks文件夹下有很多git默认自带的钩子文件，这里我们主要使用pre-commit这个钩子文件。<br>我们找到.git&#x2F;hooks&#x2F;pre-commit文件，修改当前文件里的内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;我是测试pre-commit钩子命令的&#x27;</span><br></code></pre></td></tr></table></figure><p>然后在git 面板里执行git commit 命令，可以看到我们在执行git commit 命令时候触发了pre-commit钩子，输出了：’我是测试pre-commit钩子命令的’。如下图</p><p><img src="/2019/08/26/husky/commit.webp" alt="hook/pre-commit"><br>我们在.git&#x2F;hooks&#x2F;pre-commit文件里执行了输出一行字，那如果我们修改当然文件，让文件执行eslint校验，如下图<br><img src="/2019/08/26/husky/commit2.webp" alt="执行eslint校验"></p><p>注意.git&#x2F;hooks&#x2F;pre-commit文件里写 npm run eslint 那么一定要在package.json文件里添加如下代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;eslint&quot;</span>: <span class="hljs-string">&quot;eslint --ext .js,.vue zdyProject/&quot;</span> <span class="hljs-regexp">//</span>注意这个zdyProject/是我测试的文件目录，请根据自己代码自行修改<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里基本就完成了git提交时执行eslint校验功能了。但是在实际的团队项目里我们并不会这样做，因为我们是团队合作，.git&#x2F;hooks&#x2F;pre-commit文件修改后只会在本地，并不能上传到git上供其它成员使用，因为git会忽略.git文件夹下的文件。这个时候husky就可以解决这个问题。</p><h2 id="2、husky"><a href="#2、husky" class="headerlink" title="2、husky"></a>2、husky</h2><p>github为了解决.git配置不能提交远程仓库的问题，husky 出来了，husky 在你npm i安装完依赖只有自动执行husky install。</p><h6 id="2-1、安装husky"><a href="#2-1、安装husky" class="headerlink" title="2.1、安装husky"></a>2.1、安装husky</h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> husky -D<br></code></pre></td></tr></table></figure><h6 id="2-2、使用husky"><a href="#2-2、使用husky" class="headerlink" title="2.2、使用husky"></a>2.2、使用husky</h6><p>编辑package.json在script里添加prepare的值为husky install</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;prepare&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;husky install&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>然后执行npm run prepare，这个命令做了什么事呢 ？实际上就是创建 .husky 目录，修改了.git&#x2F;config文件里的hooksPath字段（设置 .husky 目录为 git hooks 目录）</p><p><img src="/2019/08/26/husky/commit3.webp" alt="eslint"></p><p>我们在.husky目录下创建一个pre-commit文件，里面放入代码 npm run eslint(如下图a)。</p><p>我们随便修改一下项目里的文件，然后执行git add .，git commit -m ‘测试husky’，发现代码已经被拦截，没有提交，因为index.vue代码不符合规范(效果如下图a)。<br><img src="/2019/08/26/husky/commit4.webp" alt="效果"><br>到这里husky的简单配置已经完成，但是试想一下有没有问题？，假如项目里有a.js，b.js文件，我修改了a.js，b.js文件，但是我执行了git add a.js(也就是只把a.js文件提到了git缓存)，那如果我们现在git commit 应该也只应该校验a.js才对，但是按照上面的配置，我们会在git commit的时候会校验的项目下的全部文件，这显然不对，也就是我们.husky目录下的pre-commit文件内容显然是不能够做到这样的，这时候就必须改写pre-commit文件内容，pre-commit文件是一个shell文件，对前端而言肯定是一大难题，不好写。这个时候就要用到lint-staged，用它来解决这个问题。</p><h6 id="3、lint-staged"><a href="#3、lint-staged" class="headerlink" title="3、lint-staged"></a>3、lint-staged</h6><p>lint-staged作用：对 Git 暂存区代码文件进行 bash 命令操作等等。<br>先安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i lint-staged -D<br></code></pre></td></tr></table></figure><p>package.json添加script</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;eslint&quot;</span>: <span class="hljs-string">&quot;lint-staged&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;*.&#123;js,vue&#125;&quot;</span>: [<br>      <span class="hljs-string">&quot;prettier --write&quot;</span>,<br>      <span class="hljs-string">&quot;eslint --ext .js,.vue&quot;</span><br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure><p>随便修改一下项目里a.js，b.js文件，然后执行git add a.js，git commit -m ‘test’，可以发现调用了 eslint 去检查代码，eslint只检查了a.js文件，并没有校验b.js文件。检查不通过就退出commit。如下图b</p><p><img src="/2019/08/26/husky/commit5.webp" alt="效果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>eslint</tag>
      
      <tag>husky</tag>
      
      <tag>prettier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多个前端项目中公共组件使用方案（npm包方式）</title>
    <link href="/2019/08/07/npmLink/"/>
    <url>/2019/08/07/npmLink/</url>
    
    <content type="html"><![CDATA[<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><blockquote><p>公司有多个前端项目，每个项目独立部署，各个项目里可能会使用相同的组件或者页面。对于这样的组件或者页面如何管理呢？我们可以把公共的组件或者页面抽离，单独存放在一个项目里，然后在其他项目里引入这个公共的项目</p></blockquote><h2 id="2、方案"><a href="#2、方案" class="headerlink" title="2、方案"></a>2、方案</h2><p>2.1 创建一个公共组件项目commonpack（名字自己定义），如下图</p><p><img src="/2019/08/07/npmLink/7579449-fe3d160bceb6079d.webp" alt="项目结构"></p><!--  --><p>outPages目录里是公共组件pageA和pageB，然后在根目录下创建index.js,向外暴露组件pageA和pageB。index.js文件里面代码如下</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> pageA <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./outPages/pageA&#x27;</span><br><span class="hljs-keyword">import</span> pageB <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./outPages/pageB&#x27;</span><br><span class="hljs-keyword">export</span> &#123;<br>  pageA,<br>  pageB<br>&#125;<br></code></pre></td></tr></table></figure><p>2.2 创建一个标准的前端项目packageone,packagetwo，那么packageone,packagetwo如何来引入公共组件项目commonpack里的组件pageA和pageB呢？有3个方案。</p><h6 id="方案一：npm发布引用"><a href="#方案一：npm发布引用" class="headerlink" title="方案一：npm发布引用"></a>方案一：npm发布引用</h6><p>公共组件项目commonpack的组件编写完成后，将其发布到npm。开发packageone,packagetwo的人员通过npm install命令将commonpack以node_module的方式引入</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install commonpack <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>另外，每次改动代码再次发布时，需要修改package.json文件中的版本号，不然发布不成功。<br>这种方法在开发阶段不便捷，改个公共组件，改完还得发包，发完后其他项目使用还得从新安装。</p><h6 id="方案二：npm-link"><a href="#方案二：npm-link" class="headerlink" title="方案二：npm link"></a>方案二：npm link</h6><p>首先进入commonpack包，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p>这会创建一个软连接，并保存到目录C:\Users\Administrator\AppData\Roaming\npm\node_modules下面。<br>然后进入packageone和packagetwo，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span> commonpack<br></code></pre></td></tr></table></figure><p>这就将这个公共的项目通过软连接的方式引入到项目里面来了。下图可以看到在node_modules中common包和其他的包文件夹样式是不一样的，common文件夹只是一个软链接。</p><p><img src="/2019/08/07/npmLink/common.webp" alt="软链接"></p><p>这时修改commonpack项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。<br>需要注意的是，当项目包依赖更新后，也就是执行了 npm install xxx 之后，需要重新link common项目。而且使用npm link后本地package.json里没有记录，无法直观的查看本地包的引用。</p><h6 id="方案三：npm本地file引用（推荐）"><a href="#方案三：npm本地file引用（推荐）" class="headerlink" title="方案三：npm本地file引用（推荐）"></a>方案三：npm本地file引用（推荐）</h6><p>分别进入packageone和packagetwo，在控制台输入命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install ..<span class="hljs-regexp">/commonpack/</span><br></code></pre></td></tr></table></figure><p>其中&#x2F;commonpack&#x2F;是commonpack的相对路径，这里也可以输入绝对路径。<br>这样就将commonpack这个工程以node_module的方式引入到packageone和packagetwo项目中了。可以正常使用commonpack在index.js中导出的组件了。<br>命令执行完后，package.json里会多一条记录<br><img src="/2019/08/07/npmLink/package.webp" alt="tupian123"></p><p>同样这时修改common项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。而且在package.json中有引入记录。</p><h6 id="3、举例"><a href="#3、举例" class="headerlink" title="3、举例"></a>3、举例</h6><p>我们在packageone项目里引入公共组件pageA和pageB</p><p><img src="/2019/08/07/npmLink/page1.webp" alt="组件引用"></p><h6 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h6><p><img src="/2019/08/07/npmLink/tu.webp" alt="效果图"></p><p>github项目地址：<a href="https://github.com/Amosyue/npmPackages">https://github.com/Amosyue/npmPackages</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>多个前端项目</tag>
      
      <tag>npm包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写 promise 方法之catch，finally方法</title>
    <link href="/2019/05/05/promiseMethods/"/>
    <url>/2019/05/05/promiseMethods/</url>
    
    <content type="html"><![CDATA[<blockquote><p>手写 promise 方法之catch，finally方法之前建议先阅读：<a href="/2019/05/01/writePromise/">手写promise方法</a>.</p></blockquote><p>需要注意，finally和catch方法只是then的一个别名，实际上返回的还是一个promise，完全可以这样写：promise.then().finally().then().catch().then()</p><h2 id="catch-方法"><a href="#catch-方法" class="headerlink" title="catch 方法"></a>catch 方法</h2><blockquote><p>catch 方法是 then 方法的语法糖，只接受 rejected 态的数据。既然catch 方法是 then 方法的语法糖，那么我们直接调用即可。我们把上一篇文章的代码拷贝一个简要的过来。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  <span class="hljs-keyword">static</span> pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  <span class="hljs-keyword">static</span> fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  <span class="hljs-keyword">static</span> rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-comment">//省略了代码，完整的看上一篇文章</span><br>  &#125;<br>  then = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">//then方法，这里省略，完整的看上一篇文章,这里现在看其实是有点问题，promise的then方法是定义在原型上，我这里这样写，等于是把then方法定义在实例对象上了。但是不影响，原理是一样的。</span><br>  &#125;<br>  <span class="hljs-comment">//catch方法定义在原型上</span><br>  <span class="hljs-keyword">catch</span>(onRejected)=&gt;&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,onRejected)<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="finally-方法"><a href="#finally-方法" class="headerlink" title="finally 方法"></a>finally 方法</h2><blockquote><p>finally() 方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。这避免了同样的语句需要在 then() 和 catch() 中各写一次的情况。注意此方法的回调函数中不接收任何参数。因此它仅用于无论最终结果如何都要执行的情况。如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，finally() 方法可能是有用的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  <span class="hljs-keyword">static</span> pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  <span class="hljs-keyword">static</span> fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  <span class="hljs-keyword">static</span> rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-comment">//省略了代码，完整的看上一篇文章</span><br>  &#125;<br>  then = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">//then方法，这里省略，完整的看上一篇文章</span><br>  &#125;<br>  onFinally = <span class="hljs-function">(<span class="hljs-params">onFinally</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(onFinally,onFinally)<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>原型链的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">Myfinally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-title function_">callback</span>()<br>    <span class="hljs-keyword">return</span> value<br>  &#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-title function_">callback</span>()<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>promise，手写promise</tag>
      
      <tag>catch，finally</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解promise原理之手写promise</title>
    <link href="/2019/05/01/writePromise/"/>
    <url>/2019/05/01/writePromise/</url>
    
    <content type="html"><![CDATA[<blockquote><p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。建议在看本文之前先大致浏览一遍 <a href="https://promisesaplus.com/" title="Promises/A+ 规范">Promises&#x2F;A+ 规范</a>，或许你更有收获。</p></blockquote><h2 id="1、基础版-Promise"><a href="#1、基础版-Promise" class="headerlink" title="1、基础版 Promise"></a>1、基础版 Promise</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Promise 执行函数是立即执行的&#x27;</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">2000</span>);<br>  <span class="hljs-comment">//resolve(1)</span><br>&#125;);<br>p.then(<br>  <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(val),<br>  err =&gt;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err)<br>);<br><span class="hljs-comment">// Promise 执行函数是立即执行的</span><br><span class="hljs-comment">// 1 （2 秒以后）</span><br></code></pre></td></tr></table></figure><p>从以上回顾可以看出：<br>1、Promise 是一个构造函数<br>2、new Promise 时候传入一个执行函数，此函数是立即执行的<br>3、执行函数接收 2 个参数，分别是 resolve 函数和 reject 函数，并且均能够接收参数<br>4、Promise 的实例上有 then 方法，then 方法接收 2 个参数</p><p>根据以上分析，可以简单的写出一个简易版的 promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  <span class="hljs-keyword">static</span> pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  <span class="hljs-keyword">static</span> fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  <span class="hljs-keyword">static</span> rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">Mypromise</span>.<span class="hljs-property">pending</span>;<span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">//成功结果</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    &#125;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>      <span class="hljs-title function_">reject</span>(e)<span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>promise&#x2F;A+规范中规定，当Promise对象已经由等待态（Pending）改变为执行态（Fulfilled）或者拒绝态（Rejected）后，就不能再次更改状态，且终值也不可改变。那么接下来我们来完善 resolve 和 reject 函数,</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  static pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  static fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  static rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-keyword">constructor</span>(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.pending;<span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-keyword">this</span>.value = undefined;<span class="hljs-comment">//成功结果</span><br>    <span class="hljs-keyword">this</span>.reason = undefined;<span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">const</span> resolve = (value)=&gt;&#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending )&#123;<br>        <span class="hljs-keyword">this</span>.value = value<br>        <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = (reason)=&gt;&#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending )&#123;<br>        <span class="hljs-keyword">this</span>.reason = reason<br>        <span class="hljs-keyword">this</span>.status = Mypromise.rejected <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      executor(resolve, reject);<span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>      reject(e)<span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、then方法实现"><a href="#2、then方法实现" class="headerlink" title="2、then方法实现"></a>2、then方法实现</h2><p>then方法,是这里比较复杂的功能；尤其注意：then方法特性<br>1、首先判断两个参数是否为函数类型，因为这两个参数是可选参数<br>2、当参数不是函数类型时，其必须被忽略,默认会创建一个函数赋值给对应的参数，同时也实现了透传.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  static pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  static fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  static rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-keyword">constructor</span>(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.pending;<span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-keyword">this</span>.value = undefined;<span class="hljs-comment">//成功结果</span><br>    <span class="hljs-keyword">this</span>.reason = undefined;<span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">const</span> resolve = (value)=&gt;&#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending )&#123;<br>        <span class="hljs-keyword">this</span>.value = value<br>        <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = (reason)=&gt;&#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending )&#123;<br>        <span class="hljs-keyword">this</span>.reason = reason<br>        <span class="hljs-keyword">this</span>.status = Mypromise.rejected <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      executor(resolve, reject);<span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>      reject(e)<span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>  then = (onFulfilled,onRejected)=&gt;&#123;<br>    onFulfilled = typeof onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : value =&gt; value<br>    onRejected = typeof onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : value =&gt; value<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending)&#123;<br>      onFulfilled(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.fulfilled)&#123;<br>      onFulfilled(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.rejected)&#123;<br>      onRejected(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里一个简单的promise已经基本实现，我们来测试一下。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  resolve(<span class="hljs-string">&#x27;张三&#x27;</span>)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data) <span class="hljs-comment">//输出张三</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的代码我们是直接resolve的值，可以理解是同步方法，那么我们我们使用下边的代码验证一下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;张三&#x27;</span>)<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(data)</span>=&gt;</span>&#123;<br>  console.log(data) <span class="hljs-regexp">//</span>期望是<span class="hljs-number">3</span>秒后输出：张三。可结果是直接输出undefind<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里then里面函数运行时，resolve函数是在定时器里，是异步执行的，还没有来得及修改status，此时还是pending状态,故结果肯定正确，因此我们需要对异步的情况做一下处理。</p><h2 id="3、then支持异步"><a href="#3、then支持异步" class="headerlink" title="3、then支持异步"></a>3、then支持异步</h2><p>那么如何让我们的Promise来支持异步呢？我们可以参考发布订阅模式，在执行then方法的时候，如果当前还是pending状态，就把回调函数寄存到一个数组中，当状态发生改变时，去数组中取出回调函数；因此我们先在Mypromise中定义一下变量：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(executor)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.fulfilledCallbacks = [] //成功的回调</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.rejectedCallbacks = [] //失败的回调</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p>then方法也改造一下如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">then</span> =<span class="hljs-function"> (<span class="hljs-params">onFulfilled</span>,<span class="hljs-params">onRejected</span>)=&gt;</span>&#123;<br>  onFulfilled = typeof onFulfilled<span class="hljs-operator"> === </span>&#x27;<span class="hljs-keyword">function</span>&#x27; ? onFulfilled :<span class="hljs-function"> <span class="hljs-params">value</span> =&gt;</span> value<br>  onRejected = typeof onRejected<span class="hljs-operator"> === </span>&#x27;<span class="hljs-keyword">function</span>&#x27; ? onRejected :<span class="hljs-function"> <span class="hljs-params">value</span> =&gt;</span> value<br>  <span class="hljs-comment">//当then执行时，如果还是pending状态，我们不是马上去执行回调函数，而是将其存储起来</span><br>  <span class="hljs-keyword">if</span>(this.status<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Mypromise</span>.</span></span>pending)&#123;<br>    this.fulfilledCallbacks.push(onFulfilled)<br>  &#125;<br>  <span class="hljs-keyword">if</span>(this.status<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Mypromise</span>.</span></span>fulfilled)&#123;<br>    on<span class="hljs-constructor">Fulfilled(<span class="hljs-params">this</span>.<span class="hljs-params">value</span>)</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(this.status<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Mypromise</span>.</span></span>rejected)&#123;<br>    on<span class="hljs-constructor">Rejected(<span class="hljs-params">this</span>.<span class="hljs-params">value</span>)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>存储起来后，当resolve或者reject异步执行的时候就可以来调用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>  <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled; <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>    <span class="hljs-comment">//调用存储起来的成功方法</span><br>    <span class="hljs-keyword">this</span>.fulfilledCallbacks.forEach(cb=&gt;cb(<span class="hljs-keyword">this</span>.value))<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>  <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>    <span class="hljs-keyword">this</span>.reason = reason;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.rejected; <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>    <span class="hljs-comment">//调用存储起来的失败方法</span><br>    <span class="hljs-keyword">this</span>.rejectedCallbacks.forEach(cb=&gt;cb(<span class="hljs-keyword">this</span>.reason))<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  static pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  static fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  static rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-keyword">constructor</span>(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.pending; <span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-keyword">this</span>.value = undefined; <span class="hljs-comment">//成功结果</span><br>    <span class="hljs-keyword">this</span>.reason = undefined; <span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">this</span>.fulfilledCallbacks = [] <span class="hljs-comment">//成功的回调</span><br>    <span class="hljs-keyword">this</span>.rejectedCallbacks = [] <span class="hljs-comment">//失败的回调</span><br>    <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled; <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>        <span class="hljs-keyword">this</span>.fulfilledCallbacks.forEach(cb=&gt;cb(<span class="hljs-keyword">this</span>.value))<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>        <span class="hljs-keyword">this</span>.status = Mypromise.rejected; <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>        <span class="hljs-keyword">this</span>.rejectedCallbacks.forEach(cb=&gt;cb(<span class="hljs-keyword">this</span>.reason))<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor(resolve, reject); <span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e); <span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>  then = (onFulfilled,onRejected)=&gt;&#123;<br>    onFulfilled = typeof onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : value =&gt; value<br>    onRejected = typeof onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : value =&gt; value<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.pending)&#123;<br>      <span class="hljs-keyword">this</span>.fulfilledCallbacks.push(onFulfilled)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.fulfilled)&#123;<br>      onFulfilled(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === Mypromise.rejected)&#123;<br>      onRejected(<span class="hljs-keyword">this</span>.value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在测试一下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;张三&#x27;</span>)<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(data)</span>=&gt;</span>&#123;<br>  console.log(data) //<span class="hljs-number">3</span>秒后输出：张三。表明<span class="hljs-keyword">then</span>异步方法改造成功。<br>&#125;)<br></code></pre></td></tr></table></figure><p>到此我们写的Mypromise方法已经可以简单使用了，距离成功又近了一步。但是多个then的时候就出现了问题，比如:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;张三&#x27;</span>)<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data) <span class="hljs-comment">//3秒后输出：张三。表明then异步方法改造成功。</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码第二个then会报错，看来我们还得继续努力，但是别急，我们一步步来，肯定可以成功！下边我们就来逐步完善缺失的功能。</p><h2 id="4、then链式调用"><a href="#4、then链式调用" class="headerlink" title="4、then链式调用"></a>4、then链式调用</h2><p>promise&#x2F;A+规范中规定：</p><blockquote><p>then 方法必须返回一个 promise 对象<br>promise2 &#x3D; promise1.then(onFulfilled, onRejected);<br>也就是说，每个then方法都要返回一个新的Promise对象，这样我们的then方法才能不断的链式调用；因此上面then方法就不适用了，因为它什么都没有返回，我们对其进行简单的改写，不论then进行什么操作，都返回一个新的Promise对象,新的then方法是如下格式。</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">then = <span class="hljs-function">(<span class="hljs-params">onFulfilled,onRejected</span>)=&gt;</span>&#123;<br>  onFulfilled = <span class="hljs-built_in">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value<br>  onRejected = <span class="hljs-built_in">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value<br>  <span class="hljs-keyword">var</span> promise2 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br><br>  &#125;)<br>  <span class="hljs-keyword">return</span> promise2<br>&#125;<br></code></pre></td></tr></table></figure><p>then的执行过程：</p><p>1、如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)<br>2、如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e<br>3、如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值<br>4、如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的原因</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title">then</span> = <span class="hljs-params">(onFulfilled, onRejected)</span> =&gt;</span> &#123;<br>  onFulfilled =<br>    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> value;<br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> value;<br>  <br>  var promise2 = <span class="hljs-keyword">new</span> Mypromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (this.status === Mypromise.pending) &#123;<br>      <span class="hljs-regexp">//</span>传入的函数的函数体需要异步执行，这是规范规定的<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        this.fulfilledCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>          let x = onFulfilled(this.value);<br>          this.resolvePromise(promise2, x, resolve, reject);<br>        &#125;);<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (this.status === Mypromise.fulfilled) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        let x = onFulfilled(this.value);<br>        this.resolvePromise(promise2, x, resolve, reject);<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (this.status === Mypromise.rejected) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        let x = onFulfilled(this.reason);<br>        this.resolvePromise(promise2, x, resolve, reject);<br>      &#125;)<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise2;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>首先我们返回了一个新的 Promise 对象，并在 Promise 中传入了一个函数<br>函数的基本逻辑还是和之前一样，往回调数组中 push 函数<br>同样，在执行函数的过程中可能会遇到错误，所以使用了 try…catch 包裹<br>规范规定，执行 onFulfilled 或者 onRejected 函数时会返回一个 x，并且执行 Promise 解决过程，这是为了不同的 Promise 都可以兼容使用，比如 JQuery 的 Promise 能兼容 ES6 的 Promise 接下来我们改造判断执行态的逻辑</p></blockquote><h2 id="5、resolvePromise的实现"><a href="#5、resolvePromise的实现" class="headerlink" title="5、resolvePromise的实现"></a>5、resolvePromise的实现</h2><p>首先规范规定了 x 不能与 promise2 相等，这样会发生循环引用的问题，比如如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p1 = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> p1<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以resolvePromise函数第一步就会校验promise2 是否等于 x</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title">resolvePromise</span> = <span class="hljs-params">(promise2, x, resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不允许操作&#x27;</span>));<br>  &#125;<br></code></pre></td></tr></table></figure><p>完整的resolvePromise函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript">resolvePromise = <span class="hljs-function">(<span class="hljs-params">promise2, x, resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;不能循环引用&#x27;</span>));<br>  &#125;<br>  <span class="hljs-comment">//promise/A+ 规范2.3.2规定如果x是一个promise，采用它的状态 .</span><br>  <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Mypromise</span>)&#123;<br>    <span class="hljs-keyword">if</span>(x.<span class="hljs-property">status</span> === <span class="hljs-title class_">Mypromise</span>.<span class="hljs-property">pending</span>)&#123;<br>      x.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>)&#123;<br>        <span class="hljs-comment">// 递归下去，直到遇到第一个非promise，promise2就会解决/拒绝</span><br>        <span class="hljs-title function_">resolvePromise</span>(promise2,y,resolve,reject)<br>      &#125;,reject)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      x.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//promise/A+ 规范2.3.3 如果x是一个对象或函数</span><br>  <span class="hljs-keyword">if</span> ((x &amp;&amp; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> used; <span class="hljs-comment">//premose2是否已经resolve或者reject,按规定promise的resolve，reject只能调用一次。</span><br>    <span class="hljs-comment">//这里处理的是我们写的Mypromise与别人写的promise对象做交互的情况，经可能的考虑兼容性，考虑到别人乱写promise的情况。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">let</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>            used = <span class="hljs-literal">true</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>            used = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;,<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>        used = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>      used = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//x是一个普通的值</span><br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>到这里以及完成了resolvePromise方法。</p><p>下边就是完整的Mypromise方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mypromise</span> &#123;<br>  static pending = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  static fulfilled = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  static rejected = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  <span class="hljs-keyword">constructor</span>(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = Mypromise.pending; <span class="hljs-comment">//将初始状态设置为pending</span><br>    <span class="hljs-keyword">this</span>.value = undefined; <span class="hljs-comment">//成功结果</span><br>    <span class="hljs-keyword">this</span>.reason = undefined; <span class="hljs-comment">//失败原因</span><br>    <span class="hljs-keyword">this</span>.fulfilledCallbacks = []; <span class="hljs-comment">//成功的回调</span><br>    <span class="hljs-keyword">this</span>.rejectedCallbacks = []; <span class="hljs-comment">//失败的回调</span><br>    <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.status = Mypromise.fulfilled; <span class="hljs-comment">//修改值后，状态由pending变成fulfilled</span><br>        <span class="hljs-keyword">this</span>.fulfilledCallbacks.forEach((cb) =&gt; cb(<span class="hljs-keyword">this</span>.value));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>      <span class="hljs-comment">//只能是pending状态的时候才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>        <span class="hljs-keyword">this</span>.status = Mypromise.rejected; <span class="hljs-comment">//报错后，状态由pending变成rejected</span><br>        <span class="hljs-keyword">this</span>.rejectedCallbacks.forEach((cb) =&gt; cb(<span class="hljs-keyword">this</span>.reason));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">//执行函数executor可能存在异常，因此通过try/catch来捕获一下异常情况</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor(resolve, reject); <span class="hljs-comment">//调用执行函数，将resolve和reject方法作为参数传入</span><br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e); <span class="hljs-comment">//若执行函数中存在异常直接用抛出的值来拒绝promise</span><br>    &#125;<br>  &#125;<br>  then = (onFulfilled, onRejected) =&gt; &#123;<br>    onFulfilled =<br>      typeof onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : (value) =&gt; value;<br>    onRejected =<br>      typeof onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : (value) =&gt; value;<br><br>    <span class="hljs-keyword">var</span> promise2 = new Mypromise((resolve, reject) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.pending) &#123;<br>        <span class="hljs-keyword">this</span>.fulfilledCallbacks.push(() =&gt; &#123;<br>          let x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>          <span class="hljs-keyword">this</span>.resolvePromise(promise2, x, resolve, reject);<br>        &#125;);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.fulfilled) &#123;<br>        <span class="hljs-comment">// onFulfilled(this.value);</span><br>        let x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        <span class="hljs-keyword">this</span>.resolvePromise(promise2, x, resolve, reject);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === Mypromise.rejected) &#123;<br>        <span class="hljs-comment">// onRejected(this.value);</span><br>        let x = onFulfilled(<span class="hljs-keyword">this</span>.reason);<br>        <span class="hljs-keyword">this</span>.resolvePromise(promise2, x, resolve, reject);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>  resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>      reject(new TypeError(<span class="hljs-string">&#x27;不能循环引用&#x27;</span>));<br>    &#125;<br>    <span class="hljs-comment">//promise/A+ 规范2.3.2规定如果x是一个promise，采用它的状态 .</span><br>    <span class="hljs-keyword">if</span>(x instanceof Mypromise)&#123;<br>      <span class="hljs-keyword">if</span>(x.status === Mypromise.pending)&#123;<br>        x.then(function(y)&#123;<br>          <span class="hljs-comment">// 递归下去，直到遇到第一个非promise，promise2就会解决/拒绝</span><br>          resolvePromise(promise2,y,resolve,reject)<br>        &#125;,reject)<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        x.then(resolve, reject);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//promise/A+ 规范2.3.3 如果x是一个对象或函数</span><br>    <span class="hljs-keyword">if</span> ((x &amp;&amp; typeof x === <span class="hljs-string">&#x27;object&#x27;</span>) || typeof x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      let used; <span class="hljs-comment">//premose2是否已经resolve或者reject,按规定promise的resolve，reject只能调用一次。</span><br>      <span class="hljs-comment">//这里处理的是我们写的Mypromise与别人写的promise对象做交互的情况，经可能的考虑兼容性，考虑到别人乱写promise的情况。</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        let then = x.then;<br>        <span class="hljs-keyword">if</span> (typeof then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          then.call(<br>            x,<br>            (y) =&gt; &#123;<br>              <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>              used = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">this</span>.resolvePromise(promise2, y, resolve, reject);<br>            &#125;,<br>            (r) =&gt; &#123;<br>              <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>              used = <span class="hljs-literal">true</span>;<br>              reject(r);<br>            &#125;,<br>          );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>          used = <span class="hljs-literal">true</span>;<br>          resolve(x);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">if</span> (used) <span class="hljs-keyword">return</span>;<br>        used = <span class="hljs-literal">true</span>;<br>        reject(e);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//普通的值的情况</span><br>      resolve(x);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>promise，手写promise</tag>
      
      <tag>resolvePromise</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
